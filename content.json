{"pages":[{"title":"","text":"个人介绍 基本信息 郑博 / 男 / 1996 专科 / 成都纺织高等专科学校 （非计算机专业,大二自学,大三接私活,毕业参加工作） 工作年限 / 经验：3年&emsp;2020.01-至今 期望职位：Web前端程序员 / 工程师 现在薪资：12k-13k ； 期望薪资：税前月薪16k-20k，特别喜欢的公司可例外 Email：130141963@qq.com&emsp;&emsp;QQ：130141963&emsp;&emsp;VX：TabbyCute404 自我评价 自学能力强，独立解决问题能力突出，能给项目团队困难的时候及时给出解决方案。 喜欢自己动手封装高可用的代码，为以后的开发提高效率。 喜欢学习新技术，经常了解和学习前沿的技术。有些东西可能没有时间去学习。但是了解过了，能快速的定位问题，给出解决方案。 喜欢挑战未知的项目，一般的项目千篇一律，过于常规没什么意思，喜欢做点不一样的 ~ 有良好的沟通能力和团队合作能力，性格随和，认真负责。对于同事的需要有求必应。 抗压能力强，有信心在不同的工作强度下进行开发工作，年轻！不多bb 对新公司的适应能力强，自学能力极强，能快速融入团队。 项目经验 自学能力强，喜欢挑战未知，项目经历丰富，上线项目数量、类别繁多(各种各样的项目都做过)，在自己看来算是比较丰富多彩。 以下项目均为自己为公司的&nbsp;独立产出&nbsp;项目，团队项目不予介绍。 2022-04-09&emsp;从新美云项目部换到项目二部，为项目二部提供移动端开发。 《Hot Money》官网。老板说为了和竞争对手抢占市场必须做SEO的优化收集用户，裂开！经过我的考虑，准备采用NextJS来完成此项目。开始采用 Nuxt3.0+TS 发现问题真的巨多(可能是因为Bate版)，网上的文档也少，后来退回到Nuxt2.0。毕竟赶时间。 NuxtJS / Ant Design / Google登录 / Face登录 / Lottie 《飞音IM》移动端-Flutter。在我的强烈推荐下，采用flutter对之前的im项目进行重构。功能啥的基本一样！性能更好，体验nice，完美~ iOS / Android / Flutter / JPush / Agora SDK 《Hot Money》是自己公司面对海外游戏市场的一款游戏对战平台，玩家可以在上面进行游戏对战，和邀请玩家，获得奖励。h5部分就是为项目提供邀请，注册（FaceBook，Google），玩家匹配，对战等服务。第一次对接Google登录和Face登录。 Vue3.x + Vite + Pinia / Varlet(Material质感的UI很适合海外) / Google登录 / Face登录 / Lottie 《飞音IM》移动端-Uniapp。公司内部的IM系统。为公司游戏群和海外团队提供交流平台。项目比一般的IM系统要多出一些特殊功能，由于IM项目比一般的项目更加的复杂。uniapp过于轻量，性能受限，做im这种大型，io密集，业务复杂的项目确实不好（推荐老板用Flutter或者原生，老板觉得Flutter过于冷门，成本较高）。虽然有h5+加持但是仍然有很多地方很难去实现，比如对文件的加密解密，即便有了h5+ 在uniapp的iO读写相当于没有，很难直接对二进制进行操作。在安卓端我都自己采用原生安卓写的Uniapp插件来实现对文件的加密。iOS端则是由公司的ios同事完成的Uniapp插件。后期建议用flutter重构。 iOS / Android / Uniapp / JPush 2021-09-01&emsp;加入创与互动的新美云项目部。此公司主要是以海外游戏项目为主，但是我加入的是新美云项目，我们主要是自己的项目医疗健康行业，前端vue2.x为主admin后台，后端是java。感觉挺好的~ 《新美云商城》。小程序可以直接搜，这是成都新美云健康科技有限公司的线上商城（本质是一个线上SaaS商城），业务逻辑稍显复杂。 Vue / Uniapp / uView / 微信小程序 《新美云收银平板端》。给门店的前台和门店助理的平板提供服务。项目简单，主要功能：用于给客户介绍我们公司，给通过后台系统给客户打印单据，填写用户信息，收付款等。 iPad / Uniapp / uView / iOS 《新美云收银后台》。新美云SaaS系统的订单处理中心。 vue2.x / Element UI 2021-08-25&emsp;博阳离职。一直被外派到的兰州，此公司技术老旧，感觉待下去没什么意思，遗憾退场。 2021-06-24&emsp;加入博阳。成都是分公司，母公司隶属兰州。主要业务是政府的项目，为他们使用了公司第一个Flutter项目，前端vue为主，其他的包括JQ，还有很多原生的html页面。后端是java。业务单一技术老旧，有点失望。 《某地消防队数字消防OA系统》。大概包括消防员生的活监控管理包括饮食，休息时间，假期管理，装备维护进度，当前可用车辆，车辆保养日期和进度等等… Vue / JQ / Ant Design Vue / VantUI 《某省公安厅APP内置地图》。这个项目很特殊，他是星火平台(省厅内部厂商)的 Hybrid App 混合页面，虽然项目不大只是一个功能，这个项目是我做了这么久前端，写过最烂的项目了，因为老板强制要求使用原生html+js的来完成！！！！！，导致最后成为了一个接近4000+行的html文件，自己都感觉不妥一点都不符合面向对象的编程思想，通过层层继承让实现了一个单例的class项目结构更友好(因为后面还会有其他队友用到),传上后台测试，因为需要过5次省厅的gateway，在第三次卡住了，规划路线接口一直不通其他功能正常，一直没人解决，老板不等了，还没做完就给我分配其他的项目去了，主要缺人，没人了啊~ Html + Javascript + Es6 《某地消防队数字消防APP》华为厂商特供安卓手机。项目主体用使用flutter，内嵌各种H5页面，部分功能包括看某地路口监控，被标记人员位置，政府单位位置… Flutter / Vue(h5监控系统) / uniapp(h5生活系统) / VantUI / uView 2021-06-20&emsp;从外包公司离职，追求更高的挑战。外包公司业务很杂也很多。外包生涯中充满了充满了未知和挑战难度挺高的，在这里成长了很多挺锻炼人的，感谢~ 今后任重任道远。加油！ 2020-01-29&emsp;初出茅庐，任职于绵阳一家外包网络公司（由于种种源于不愿提及公司名称，见谅）。主要业务是小程序，app，h5，前端侧重于uniapp，后端主要是php，业务重心主要放在移动端外包上面。外包项目凌乱繁杂，项目有很多瑕疵。项目凌乱繁多，项目质量一般，以下仅是个别项目。 《E小伴陪诊》。微信小程序搜&gt;E小伴陪诊。是成都的一款在线预约医生，陪诊，诊前约号，结果送检，跑腿，一站式助医服务。 Uniapp / ColorUI 《点趣环保回收》。微信小程序搜&gt;点趣环保回收。一款在线预约废品回收微信小程序，附加功能，上下级积分关系，包含回收员端(上门回收员需要进行处理回收付费等)，内嵌积分商城。 原生微信小程序 / ColorUI / uniapp(H5积分商城) 《艺蕊好货拼团》。微信小程序搜&gt;艺蕊好货拼团。一款在线商城，本质上对附近的便利店提供拼团的平台。常规电商项目。 Uniapp / ColorUI / uView 《有住天一仁和》。微信小程序搜&gt;有住天一仁和。在线装修平台，用户可定制样式，场景定制，查看装修实时情况，客服，装修进度。 Uniapp / ColorUI / uView 《创客商院》。微信公众号搜&gt;创客商院。一款知识付费平台。上下级积分关系，在线学习，刷题，看视频。 uniapp / uview / 西瓜播放器 《麦芒装修》。微信小程序搜&gt;麦芒装修。一款在线装修预约平台，能查看各种装修案例，查看当前装修进度和其他的装修案例(vr看房外接的付费源码) 微信小程序 《师派》。应用市场(部分厂商应用市场没上去)/微信公众号搜&gt;师派。uniapp跨端项目app端，微信公众号h5端。一款在线成人考试的付费平台包括，在线刷题，看题，考试，学习计划定制，错题重练，真题在线练，真题下载。 uniapp / uview &emsp;&emsp;感谢您了解我，bye~😊","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"","text":"闲来无事，写写博客，记录下自己的成长经历。 简单的介绍下自己，本人一介粗人，从小到大学业并不优异比不得什么学霸或是什么乖孩子，因为总是对一些什么“旁门左道”充满热情。自然我脚下的路不是那么平坦，有无数的迷茫，无数的疲惫，无数的坎坷，生活的常态就是在冲破迷茫看到希望，就是走出疲惫蓬勃向上，就是踏平坎坷走向新的辉煌。我们需要有阳光照亮前行的方向，我们需要有土壤供给生生不息的能量，需要智慧帮助我们厘清混乱如麻的纷扰。我的生活不应该止步于此。生命的激流已经涌现到万丈峭壁，只要再前进一步就会变成壮丽的瀑布，我时常鼓励自己，向前吧，荡起生命之舟不必依恋和信泊破浪的船自会一路开放常新的花朵。 在来说说我的职业生涯吧。应该算是大二开始，从大二开始喜欢上编程的，我的初衷很简单，很单纯觉得会写代码很酷。经过了解，入坑了前端，即使前端已经很简单，但是对于一个初学者仍感觉很难，感觉在折磨自己……但是越折磨，我越兴奋，别误会，我并非什么变态，我不是变态也不是受虐狂。大三开始接一点外包，来刷点经验,同时很享受每次征服困难时候带来的成就感和满足感。这可能就是支撑我一路自学过来的动力。但是至今没后悔过。 不知不觉中工作至今已经有些年头，但是时间没能冲淡我对编程的热爱，也很高兴当时选择了自己喜欢的路，在闲暇之余，我仍然努力不断进取新的知识，不断扩大自己的范围，这份热爱以及心中的热情丝毫不输当年。即使我知道我自己也许，也许没有这个天赋，但是凭着这份热爱，我仍然会拼尽全力，去咆哮，去奔跑，永不停歇，拼命热爱。 路漫漫其修远兮，吾将上下而求索。 来日江湖见。 2020-01-01 22:25:14","link":"/home/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"Vue3UI库/相关工具/可视化/生态全分享 技术胖整理分享 Web UI库 ElementUI Plus一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的桌面端组件库 https://element-plus.org/zh-CN/ Ant Design of VueAnt Design 的 Vue 实现，开发和服务于企业级后台产品 https://www.antdv.com/docs/vue/introduce-cn BalmUI基于谷歌的 Material Design，附带 Vue 插件和指令，以及从简单到复杂的高度可定制组件 https://next-material.balmjs.com/ Naive UI图森Vue3的组件库，文档完整，我项目中经常使用 https://www.naiveui.com/zh-CN/os-theme arco.design字节跳动企业级产品设计系统，支持React和Vue双版本 https://arco.design/ 6, Quasar轻松构建高性能和高质量的Vue.js 3用户界面，好用，但没有中文文档 https://quasar.dev/ iDUXVue3.x 的 UI 组件库，完全使用 TypeScript 开发 https://idux.site/ TDesign腾讯业务团队在服务业务过程中沉淀的一套企业级设计体系 https://tdesign.tencent.com/ https://tdesign.tencent.com/vue-next/overview PrimeVue易于使用、多功能、高性能的 Vue UI 组件库 https://www.primefaces.org/primevue/ DevUI华为基于 Vue3 和 DevUI 设计的 UI 组件 https://vue-devui.github.io/ vuestic-uiVue 3 的免费和开源 UI 库 ,UI非常好看，并且有可用后台管理界面。 https://vuestic.dev/ Headless UI完全无样式、完全可访问的 UI 组件，旨在与 Tailwind CSS 完美集成。 https://headlessui.com/ View UI Plus基于 Vue.js 3 的企业级 UI 组件库和前端解决方案 https://www.iviewui.com/ 移动UI库 Vant有赞轻量、可靠的移动端组件库 https://vant-contrib.gitee.io/vant/#/zh-CN NutUI京东风格的轻量级移动端 Vue 组件库，非常适合移动端电商使用。 https://nutui.jd.com/#/ VarletMaterial 风格移动端组件库 ，文档非常齐全。 https://varlet.gitee.io/varlet-ui/#/zh-CN/home nutui-bingo京东基于 NutUI 的抽奖组件库，助力营销活动和小游戏场景。 https://nutui.jd.com/bingo/#/ 相关工具 unplugin-vue-componentsantfu 按需组件自动导入，开箱即用地支持 Vue 2 和 Vue 3，Tree-shakable，只注册你使用的组件，附有流行UI 库的内置解析器。 https://www.npmjs.com/package/unplugin-vue-components vuex-persistedstate在页面重新加载之间保持并重载您的 Vuex 状态 https://github.com/robinvdvleuten/vuex-persistedstate vuex-persist支持 Typescript 的Vuex插件，它能够将应用程序的状态保存到持久存储中，例如 Cookies 或 localStorage https://championswimmer.in/vuex-persist/ @vueuse/gesture手势库，使应用程序具有交互性 https://gesture.vueuse.org/ unplugin-auto-importantfu 自动导入 Vite、Webpack、Rollup 和 esbuild 的 API。支持 TypeScript。 https://github.com/antfu/unplugin-auto-import pinia-plugin-persistedstatePinia 商店的可配置持久性 https://github.com/prazdevs/pinia-plugin-persistedstate https://vue-termui.dev/一个基于 Vue.js 的终端 UI 框架，可让您轻松构建现代终端应用程序 https://vue-termui.dev/ 可视化 PdfvuerDF 查看器，使用 Mozilla 的 PDF.js，支持 Vue2 和 Vue3 https://arkokoley.github.io/pdfvuer/ vue3-marquee无缝滚动组件 https://vue3-marquee.vercel.app/ Vue-ECharts百度ECharts 的 Vue.js 组件。 配置参考Echarts官方 基于 ECharts v5+ 开发，适用于Vue.js 2/3。 https://vue-echarts.dev/ iconpark字节跳动出品，将一个SVG图标转化为多个主题，并生成React图标，Vue图标，svg图标 https://iconpark.oceanengine.com/home 插件 vue-multiselect-nextVue.js 的通用选择/多选/标记组件 https://vue-multiselect.js.org/ vue-print-nb用于印刷、简单、快速、方便、轻便的指令包装器 https://github.com/Power-kxLee/vue-print-nb vue-i18n-nextVue3的国际化插件 https://vue-i18n.intlify.dev/ vue-cropper简单的vue图片裁剪插件 http://github.xyxiao.cn/vue-cropper/example/ Vue Grid LayoutVue.js 的网格布局系统 https://jbaysolutions.github.io/ Vue Qrcode Reader允许在不离开浏览器的情况下检测和解码二维码 https://gruhn.github.io/vue-qrcode-reader/ Makeit Captcha基于 Vue3 + Vite + Canvas 开发的滑块验证码，动态生成验证滑块，结合后端的二次校验，能有效的避免被抓取模拟验证https://admin.makeit.vip/components/captcha vue3-clipboardVue 3 的 clipboard.js https://github.com/soerenmartius/vue3-clipboard vue.draggable基于Sortable.js的Vue 3拖放组件 https://sortablejs.github.io/vue.draggable.next/#/simple BetterScroll解决移动端（已支持 PC）各种滚动场景需求的插件。 https://better-scroll.github.io/docs/zh-CN/ 相关生态 Vue 插件库https://www.vue365.cn/ Pinia轻量级状态管理库，API 设计更接近Vuex 5的提案 https://pinia.vuejs.org/ Nuxt ModulesNuxt 发现我们的模块列表以增强您的Nuxt 项目 https://modules.nuxtjs.org/ Nuxt 3轻量级应用框架,可用来创建服务端渲染 (SSR) 应用 https://v3.nuxtjs.org/ vuepressVue 驱动的静态网站生成器 https://v2.vuepress.vuejs.org/zh/ VueUse强大的 Vue 组合实用程序集合 https://vueuse.org/ 动画 vue-starport带有动画的跨路由共享组件 https://vue-starport.netlify.app/ @vueuse/motionVue Composables 让你的组件动起来 https://motion.vueuse.org/ 音视频 @vueuse/sound用于播放音效的 Vue 组合 https://sound.vueuse.org/","link":"/assets/%E8%B5%84%E6%96%99/vue3.html"}],"posts":[{"title":"Hexo Tags自动摘要","text":"使用插件hexo-excerpt实现 1cnpm install hexo-excerpt --save 在站点配置文件中添加（项目的_config.yml） 12345excerpt: depth: 3 excerpt_excludes: [] more_excludes: [] hideWholePostExcerpts: true","link":"/2020/07/05/20200705hexo%E8%87%AA%E5%8A%A8%E6%91%98%E8%A6%81/"},{"title":"JSON.stringify的详解","text":"JSON.stringify尽然有3个参数的啊一直都以为只有一个。(value[, replacer [, space]]) 参数一没什么好说的,但是有几个地方需要注意 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中（对象的属性的顺序可能会改变）12var data = {name:&quot;tabby&quot;,hobs:[&quot;篮球&quot;,&quot;足球&quot;],other:{a:1,b:2,c:3}};JSON.stringify(data); 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。 undefined、任意的函数 、 symbol 键值对、不可枚举的属性、 在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。12345678var obj = {&quot;t1&quot;:undefined,&quot;t2&quot;:function(a){var a=10;return a},&quot;t3&quot;:Symbol(&quot;asdada&quot;),&quot;t4&quot;:{&quot;fnc&quot;:function(a){var a=10;return a},a:1},[Symbol(&quot;t5&quot;)]: &quot;t5&quot;};console.log(JSON.stringify(obj)) //{&quot;t4&quot;:{&quot;a&quot;:1}}var arr = [undefined,Symbol(&quot;aaa&quot;),function(){},{&quot;fnc&quot;:function(a){var a=10;return a},a:1}];console.log(JSON.stringify(arr))//[null,null,null,{&quot;a&quot;:1}]JSON.stringify( Object.create(null, { t1: { value: 't1', enumerable: false }, t2: { value: 't2', enumerable: true } }) );//{&quot;t2&quot;:&quot;t2&quot;} 参数二 当第二个参数为函数的时候，每个“key”，“value”都会经过该函数的转换和处理，1234567891011121314151617181920212223242526272829303132333435363738394041var data = { name: &quot;tabby&quot;, t1: { a: 1, b: 2, c: [&quot;cccc&quot;, 2] }};var b = JSON.stringify(data, function (key, val) { console.log(&quot;key is %s&quot;, key); console.log(&quot;val is %s , type is %s&quot;,val,typeof (val)); console.log(&quot;-----------------------------------------------------&quot;); return val;});console.log(b)//输出如下key is val is { name: 'tabby', t1: [Object] } , type is object-----------------------------------------------------key is nameval is tabby , type is string-----------------------------------------------------key is t1val is { a: 1, b: 2, c: [Array] } , type is object-----------------------------------------------------key is aval is 1 , type is number-----------------------------------------------------key is bval is 2 , type is number-----------------------------------------------------key is cval is [ 'cccc', 2 ] , type is object-----------------------------------------------------key is 0val is cccc , type is string-----------------------------------------------------key is 1val is 2 , type is number-----------------------------------------------------{&quot;name&quot;:&quot;tabby&quot;,&quot;t1&quot;:{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:[&quot;cccc&quot;,2]}} 当第二个参数为数组的时候12345678910111213var data = { name: &quot;tabby&quot;, t1: { a: 1, b: 2, c: [&quot;cccc&quot;, 1,{d:1,c:&quot;嘻嘻嘻&quot;}] }, t2:&quot;AAAAA&quot;};var b = JSON.stringify(data, [&quot;name&quot;, &quot;t1&quot;,&quot;c&quot;, &quot;cccc&quot;]);console.log(b){&quot;name&quot;:&quot;tabby&quot;,&quot;t1&quot;:{&quot;c&quot;:[&quot;cccc&quot;,1,{&quot;c&quot;:&quot;嘻嘻嘻&quot;}]}} 参数三控制序列化格式过后的缩进1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var data = { name: &quot;tabby&quot;, t1: { a: 1, b: 2, c: [&quot;cccc&quot;, 1,{d:1,c:&quot;嘻嘻嘻&quot;}] }, t2:&quot;AAAAA&quot;};var b = JSON.stringify(data,null,5);console.log(b)///{ &quot;name&quot;: &quot;tabby&quot;, &quot;t1&quot;: { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: [ &quot;cccc&quot;, 1, { &quot;d&quot;: 1, &quot;c&quot;: &quot;嘻嘻嘻&quot; } ] }, &quot;t2&quot;: &quot;AAAAA&quot;}var b = JSON.stringify(data,null,&quot;***&quot;);console.log(b)///{***&quot;name&quot;: &quot;tabby&quot;,***&quot;t1&quot;: {******&quot;a&quot;: 1,******&quot;b&quot;: 2,******&quot;c&quot;: [*********&quot;cccc&quot;,*********1,*********{************&quot;d&quot;: 1,************&quot;c&quot;: &quot;嘻嘻嘻&quot;*********}******]***},***&quot;t2&quot;: &quot;AAAAA&quot;}var b = JSON.stringify(data,null,&quot;\\t&quot;);console.log(b){ &quot;name&quot;: &quot;tabby&quot;, &quot;t1&quot;: { &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: [ &quot;cccc&quot;, 1, { &quot;d&quot;: 1, &quot;c&quot;: &quot;嘻嘻嘻&quot; } ] }, &quot;t2&quot;: &quot;AAAAA&quot;} toJSON()12345678910111213141516var data = { name: &quot;tabby&quot;, t1: { a: 1, b: 2, c: [&quot;cccc&quot;, 1,{d:1,c:&quot;嘻嘻嘻&quot;}] }, t2:&quot;AAAAA&quot;, toJSON:function(){ return &quot;我是序列化过后的数据&quot;; }};var b = JSON.stringify(data);console.log(b)&quot;我是序列化过后的数据&quot;","link":"/2020/10/01/20201001JSON.stringify%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0/"},{"title":"Http请求的Range参数精简解释","text":"主要是依赖Http请求头Range实现大文件的下载暂停，同时他还能实现文件分片下载，分片下载这里demo不做演示。 Range: &lt;数据格式&gt;=&lt;数据开始的索引位置&gt;-&lt;数据结束的索引位置&gt;； 请求从0至500的byte数据：Range: bytes=0-500 请求第500个byte以后的全部数据：Range: bytes=501- 请求最后500个byte的数据：Range:bytes=-500 请求多个分段时，各分段以,分割：Range: bytes=0-100,101-200 如果响应头中的Accept-Ranges：none； 那么服务器就不支持当前格式 请求的范围不合格或者超出文件大小都会报错超 GET http://127.0.0.1:8080/down 416 (Requested Range Not Satisfiable)416:表示Range请求的资源范围无法满足;206:支持部分返回，将返回指定部分数据；200:不支持部分返回，将从头开始完整返回数据； 响应头中将返回Content—Range字段:Content-Range: &lt;数据格式&gt; &lt;数据开始的索引位置&gt;-&lt;数据结束的索引位置&gt;/&lt;完整数据大小&gt;。 与Transfer-Encoding分块传输的差别 分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。 数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。而使用Range需要服务端在返回响应前就知道数据完整大小，因此Transfer-Encoding的响应速度相应会更快一些。两者不冲突，可以一起使用。 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF(\\r\\n)，也不包括分块数据结尾的 CRLF。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束。 Content-Encoding 和 Transfer-Encoding 二者经常会结合来用，其实就是针对 Transfer-Encoding 的分块再进行 Content-Encoding压缩。 有时候服务器开启压缩或者为了减少cpu压力等等，是不会去计算文件的总大小的，这时候从响应头中就无法获取资源的总大小。","link":"/2020/10/11/20201011Http%E8%AF%B7%E6%B1%82%E7%9A%84Range%E5%8F%82%E6%95%B0%E7%B2%BE%E7%AE%80%E8%A7%A3%E9%87%8A/"},{"title":"如何使用软键盘自定义Input框","text":"最近在项目中遇见一个问题，页面需求是输入邀请码，要能是文本，而且输入的时候上面的字符要有动画效果。 感觉实现的方法比较low，但是简单啊。哈哈哈 先看设计图 如此一来uniapp的input框是肯定无法满足我们的要求，在原生的Android或者ios上面或者flutter上面，这都不是什么难事，但是要在uniapp上这个第一时间我想到了几种方法 方案一：首先让他定位在下图位置z-index为1，当input聚焦事件触发的时候直接给他z-index为-1让在数字框后面藏起来，结果效果不触发，这个方案直接pass。 方案二：思路如上，我让他在聚焦的时候把他一道屏幕外面。结果出现了个尴尬的情况，让input输入框变化的时候视角直接拉过去了。感兴趣可以自己去尝试。总之就是pass。 最终方案：直接让他宽度超出屏幕外设置透明度为0这样用户也是无感知的。最终临时的解决了这个问题也不知道有没有更好的方法，待定这个方案。 代码如下(项目中的业务代码，无关的需要删掉) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;view class=&quot;input&quot;&gt; &lt;view v-for=&quot;i in maxLength&quot; class=&quot;item&quot;&gt; &lt;view class=&quot;num&quot; v-if=&quot;inum[i-1]&quot;&gt;{{inum[i-1]}}&lt;/view&gt; &lt;view class=&quot;con&quot; v-if=&quot;value.length+1===i&quot;&gt;&lt;/view&gt; &lt;/view&gt; &lt;input v-if=&quot;nativeKey&quot; v-model=&quot;inputValue&quot; @input=&quot;change&quot; class=&quot;input&quot; confirm-type=&quot;done&quot; /&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { props:{ value:{ type:String, default:&quot;&quot; }, maxLength:{ type:Number, default:6, }, nativeKey:{ type:Boolean, default:false, }, }, data(){ return { inputValue:&quot;&quot;, } }, computed:{ inum(){ var arr = this.value.split(&quot;&quot;) return arr } }, methods:{ change(e){ var v=e.detail.value //判断当前是否在删除 if(v.length&lt;=this.maxLength){ console.log(2,v.length) this.$emit(&quot;input&quot;,v.substring(0,7)) } } } }&lt;/script&gt;&lt;style scoped lang=&quot;stylus&quot;&gt;.input display flex align-items center justify-content space-between position relative overflow hidden input display block position absolute background-color red width 900% height 100% top 0 left -800% zIndex 10 caret-color rgba(0,0,0,0) opacity 0 user-select:none;.item width 68rpx height 90rpx border-bottom 2rpx solid #cccccc display flex justify-content center align-items center .con width: 6rpx; height: 40rpx; background: #0A293E; border-radius: 2rpx; // margin-bottom 24rpx .num font-size 48rpx font-family: PingFangSC-Medium, PingFang SC; font-weight: 500; animation:scale-out-bl .15s cubic-bezier(.55,.085,.68,.53) 0.01s reverse both&lt;/style&gt;","link":"/2020/11/09/20201109%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%BD%AF%E9%94%AE%E7%9B%98%E8%87%AA%E5%AE%9A%E4%B9%89Input%E6%A1%86/"},{"title":"浏览器的事件循环机制EventLoop及其相关理解","text":"任务队列首先我们需要明白以下几件事情： JS分为同步任务和异步任务。 同步任务都在主线程上执行，形成一个执行栈。 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。 事件循环EventLoop事件循环的概念非常简单。它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环。 1.当有任务时。从最先进入的任务开始执行。 2.休眠直到出现任务，然后转到第 1 步。当我们浏览一个网页时就是上述这种形式。JavaScript 引擎大多数时候不执行任何操作，它仅在脚本/处理程序/事件激活时执行。 当外部脚本。比如页面的script脚本加载完成时，任务就是执行它。 当用户移动鼠标时，任务就是派生出 mousemove 事件和执行处理程序。 当安排的（scheduled）setTimeout 时间到达时，任务就是执行其回调。 设置任务 —— 引擎处理它们 —— 然后等待更多任务（即休眠，几乎不消耗 CPU 资源）。一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。多个任务组成了一个队列，即所谓的“宏任务队列”。 在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 宏任务(macrotask或者task)和微任务(microtask)宏任务(task)宏任务(task)可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个task 执行开始前，对页面进行重新渲染，流程如下： 1task-&gt;microtask微任务执行-&gt;渲染-&gt;task-&gt; task主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 微任务(microtask)微任务（microtask）可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个task执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。 1234&lt;script&gt; console.log(&quot;111&quot;)setTimeout(()=&gt;{console.log(&quot;222&quot;)})&lt;/script&gt; 理解如下(这里是为了更好的理解)：这段代码111比222先出来是因为，解析script标签是任务源，也可以理解为解析script标算一次宏任务，算一次tick，执行中会将对应的任务类型分发到对应的任务队列， task【加载script标签，把console.log(“111”)添加到微任务队列，setTimeout添加到宏任务队列】-&gt;微任务执行【执行console.log(“111”)】-&gt;渲染-&gt;task【执行setTimeout】-&gt; 微任务仅来自于我们的代码。它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务。微任务也被用于 await 的“幕后”，因为它是 promise 处理的另一种形式。 microtask主要包含：Promise.then、MutaionObserver、queueMicrotask、process.nextTick(Node.js 环境) 下面的srcipt加载，mousemove，settimeout，都是宏任务 这里有必要提一下vue中的 $nextTick ，$nextTick（callback）在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM 补充一下下面需要用到的：MutationObserver是HTML5新增的属性，用于监听DOM修改事件，能够监听到节点的属性、文本内容、子节点等的改动，是一个功能强大的利器，基本用法如下： 123456789var observer = new MutationObserver(function(){ console.log('DOM被修改了！');});var dom = document.querySelector('.d');observer.observer(dom)for(let i=0; i&lt;100; i++){ dom.style.left = i + 'px';} 上面的代码，render只会渲染一次，因为这个for循环是一个task。 只要让nextTick里的代码放在UI render步骤后面执行，就能拿到更新后的dom，vue就是基于事件循环的思路实现的$nextTick。 当然vue做的更佳的严谨友好。先来看看vue内部实现的核心代码 123456789101112131415161718192021222324252627282930313233343536export let isUsingMicroTask = falseif (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) { //判断1：是否原生支持Promise const p = Promise.resolve() timerFunc = () =&gt; { p.then(flushCallbacks) if (isIOS) setTimeout(noop) } isUsingMicroTask = true} else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || MutationObserver.toString() === '[object MutationObserverConstructor]')) { //判断2：是否原生支持MutationObserver let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true }) timerFunc = () =&gt; { counter = (counter + 1) % 2 textNode.data = String(counter) } isUsingMicroTask = true} else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) { //判断3：是否原生支持setImmediate timerFunc = () =&gt; { setImmediate(flushCallbacks) }} else { //判断4：上面都不行，直接用setTimeout timerFunc = () =&gt; { setTimeout(flushCallbacks, 0) }} vue的降级策略：vue根据当前环境来判断是用什么方法(Promise.then、MutationObserver、setImmediate、setTimeout)把回调添加到render后面执行。 不管是宏任务还是微任务，他都在一个叫做flushCallbacks的函数里面从callbacks取出回调然后执行(不管是宏任务还是微任务都是在render的末尾) 12345678function flushCallbacks () { pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) { copies[i]() }} 大致流程就是 修改dom(会导致更新UI的操作) 执行this.$nextTick(cb) this.$nextTick(cb)把cb添加到内部的callbacks中， vue判断当前环境，进行降级策略 UI render渲染 flushCallbacks从callbacks中取出nextTick的回调进行执行 拆分CPU过载任务123456789101112131415let i = 0;let start = Date.now();function count() { // 做一个繁重的任务 for (let j = 0; j &lt; 1e9; j++) { i++; } alert(&quot;Done in &quot; + (Date.now() - start) + 'ms');}count(); 这种情况浏览器甚至可能会显示一个“脚本执行时间过长”的警告。让我们使用嵌套的 setTimeout 调用来拆分这个任务： 123456789101112131415161718let i = 0;let start = Date.now();function count() { // 做繁重的任务的一部分 (*) do { i++; } while (i % 1e6 != 0); if (i == 1e9) { alert(&quot;Done in &quot; + (Date.now() - start) + 'ms'); } else { setTimeout(count); // 安排（schedule）新的调用 (**) }}count(); 单次执行 count 会完成工作的一部分，然后根据需要重新安排（schedule）自身的执行，类似“多线程”： 1.首先执行计数：i=1…1000000。 2.然后执行计数：i=1000001..2000000。 但是这样他的执行耗时实际上没有多少改变让我们来做一个改进。我们将要把调度（scheduling）移动到 count() 的开头，类似“多线程”并发： 1234567891011121314151617181920let i = 0;let start = Date.now();function count() { // 将调度（scheduling）移动到开头。“多线程的感觉” if (i &lt; 1e9 - 1e6) { setTimeout(count); // 安排（schedule）新的调用 } do { i++; } while (i % 1e6 != 0); if (i == 1e9) { alert(&quot;Done in &quot; + (Date.now() - start) + 'ms'); }}count(); async，await，queueMicrotask执行分析async，await12345678910111213141516171819202122232425//请写出输出内容async function async1() { console.log('async1 start'); await async2(); console.log('async1 end');}async function async2() { console.log('async2');}console.log('script start');setTimeout(function() { console.log('setTimeout');}, 0)async1();new Promise(function(resolve) { console.log('promise1'); resolve();}).then(function() { console.log('promise2');});console.log('script end'); 1.首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。所以， 2.然后我们看到首先定义了两个async函数，接着往下看，然后遇到了 console 语句，直接输出 script start。输出之后，script 任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中： 3.script 任务继续往下执行，执行了async1()函数，前面讲过async函数中在await之前的代码是立即执行的，所以会立即输出async1 start。 遇到了await时，会将await后面的表达式执行一遍，所以就紧接着输出async2，然后将await后面的代码也就是console.log(‘async1 end’)加入到microtask中的Promise队列中，接着跳出async1函数来执行后面的代码。 4.script任务继续往下执行，遇到Promise实例。由于Promise中的函数是立即执行的，而后续的 .then 则会被分发到 microtask 的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 promise2 分配到对应队列。 5.script任务继续往下执行，最后只有一句输出了 script end，至此，全局任务就执行完毕了。 根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。 因而在script任务执行完毕之后，开始查找清空微任务队列。此时，微任务中， Promise 队列有的两个任务async1 end和promise2，因此按先后顺序输出 async1 end，promise2。当所有的 Microtasks 执行完毕之后，表示第一轮的循环就结束了。 6.第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 setTimeout，取出直接输出即可，至此整个流程结束。 queueMicrotask还有一个特殊的函数 queueMicrotask(func)，它对 func 进行排队，让func在微任务队列中执行。类似写同步代码一样，但是他是排在微任务队列的末尾 1234567891011121314151617181920console.log(1)setTimeout(()=&gt;{ console.log('宏任务1') queueMicrotask(()=&gt;{ console.log('微任务2') })})setTimeout(()=&gt;{ console.log('宏任务2') queueMicrotask(()=&gt;{ console.log('微任务3') })})queueMicrotask(()=&gt;{ console.log('微任务1')})console.log(2)// 被宏任务嵌套的微任务，在宏任务后执行，并不会有插队现象// 1 2 微任务1 宏任务1 微任务2 宏任务2 微任务3 Node的事件循环Node的事件循环是libuv实现的，引用一张官网的图： 大体的task（宏任务）执行顺序是这样的： timers定时器：本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数。 pending callbacks待定回调：执行延迟到下一个循环迭代的 I/O 回调。 idle, prepare：仅系统内部使用。 poll 轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate() 排定的之外），其余情况 node 将在此处阻塞。 check 检测：setImmediate() 回调函数在这里执行。 close callbacks 关闭的回调函数：一些准备关闭的回调函数，如：socket.on(‘close’, …)。 微任务和宏任务在Node的执行顺序 Node 10以前： 执行完一个阶段的所有任务 执行完nextTick队列里面的内容 然后执行完微任务队列的内容 Node 11以后： 和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。","link":"/2020/11/11/20201111%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"},{"title":"基于js实现一个有序任务队列","text":"最近出现一个问题，项目首页渲染的时候由于一次图片量过大（图片尺寸小且还要解密），可能会导致卡顿。如果能让他们按照顺序加载(但是加载的时间不保证，因为图片的大小不一样)。 实现了如下简易队列。基本代码虽然简单，但是我给他预留了很多可以拓展的空间。如果以后用得上那么还是挺方便的。 123456params size 容量(最大可以一起执行的任务数量) callback 任务回调。每个回调执行完了过后触发，参数为任务Promise的resovle的值method destroyed 停止队列(已经抛出的任务仍然会继续执行，这里主要是对我没什么影响，如要有其他需要可以自己定义拓展) add 每一个任务的回调，返回必须是Promise。resolve出去的值会作为callback的参数 注意，为了防止队友乱来，因为js的class并不支持私有方法和属性。我利用symbol的唯一性和闭包定义局部变量为他实现了私有方法和属性。当然私有方法和属性的实现方法不唯一，实现的方法有很多吧。比如 123456789101112131415161718192021function TbPool(){ const size = new WeakMap(); const run = new WeakMap(); class Pool { constructor(){ this.b = 'b这是公有变量'; size.set(this, '私有变量size') run.set(this, ()=&gt;{ console.log(&quot;私有方法&quot;) }) } test(){ console.log(size.get(this)); run.get(this)() } } return new Pool()}let q = TbPool()console.log(q)q.test() 业务中使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function TbPool(arg){ const listener=Symbol(&quot;listener&quot;) const taskRun=Symbol(&quot;taskRun&quot;) const tasksTimer=Symbol(&quot;tasksTimer&quot;) const queenTimer=Symbol(&quot;queenTimer&quot;) const queen=Symbol(&quot;queen&quot;) const tasks=Symbol(&quot;tasks&quot;) const size=Symbol(&quot;size&quot;) class Pool { constructor(obj={}){ this[size]=obj.size||10 this[queen]=[] this[tasks]=[] for(let i=0;i&lt;this[size];i++){this[tasks].push({status:-1,task:null})} this[listener]=function(e){ obj.callback(e) } this[taskRun]=function(index){ this[tasks][index].status=1 this[tasks][index].task().then(res=&gt;{ this[listener](res) this[tasks][index]={status:-1,task:null} }) } this[tasksTimer]=setInterval(()=&gt;{ var isHasWait=this[tasks].findIndex(item=&gt;item.status===0) if(isHasWait!==-1){ for(let i=0;i&lt;this[tasks].length;i++){if(this[tasks][i].status===0)this[taskRun](i)} } }) this[queenTimer]=setInterval(()=&gt;{ var isHasWait=this[tasks].findIndex(item=&gt;item.status===-1) if(this[queen].length&amp;&amp;(isHasWait!==-1)){ for(let i=0;i&lt;this[queen].length;i++){ var index=this[tasks].findIndex(item=&gt;item.status===-1) if(index!==-1)this[tasks][index]=this[queen].shift() } } }) } add(data=[]){ for(let i=0;i&lt;data.length;i++){ this[queen].push({status:0,task:data[i]}) } } destroyed() { clearInterval(this[tasksTimer]) clearInterval(this[queenTimer]) } } return new Pool(arg)}//初始化var q =TbPool({ size:6,//容量(最大可以一起执行的任务数量) callback:function(e){//任务回调。每个回调执行完了过后触发，参数为任务Promise的resovle的值 console.log(&quot;callback监听:&quot;,e) }})console.log(q)//每一个任务的回调，返回必须是Promisefunction f2(){ return new Promise((r)=&gt;{ setTimeout(()=&gt;{r(`当前完成任务:${new Date().valueOf()}`)},3000) })}function f3(){ //停止队列(已经抛出的任务仍然会继续执行，可以自己定义拓展) q.destroyed()}setInterval(()=&gt;{ //添加任务 q.add([f2,f2])},1000)","link":"/2020/12/09/20201209%E5%9F%BA%E4%BA%8Ejs%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"},{"title":"Fetch网络请求的轻度封装","text":"比较喜欢fetch，不需要使用任何依赖，轻量，简介。 这里时间不多，最近赶上线，下面这是稍微的封装，比较粗糙。 需要注意的是如果后端是表单解析，前端POST请求Content-Type有两个值 application/x-www-form-urlencoded; 是浏览器默认的编码格式，用于键值对参数，参数之间用&amp;间隔，POST请求，后端用表单解析； multipart/form-data; 用于键值对参数，参数之间用&amp;间隔，POST请求，后端用表单解析，他能携带二进制文件，如果GET请求的时候，Content-Type还是这个值，可能出现问题。需要注意； 大文件上传和下载的进度监听和暂停，这里时间不多，后面回来补上，先给个解决方案的思路. 大文件下载大文件的下载进度和暂停可以如下实现。如下代码实际是操作一个流的进度而已。最终把Uint8Array转成一个文件就OK。 如果想实现文件快速下载，可以考虑使用 Range 来实现同时下载多个文件段，然后把它们按照顺序拼接起来。当然 Range 也能实现文件的进度监听，不过效率不太好。每个客户端的网速不一样，比如我现在的实际网速能达到10MB/S，我们设定的是Range:0-512,这样显得很缓慢，但是对于个别网速差的客户端却很合适。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849let size = 0;var data=[]fetch(&quot;http://127.0.0.1:8080/file&quot;,{ cache: 'no-cache', // headers:{ // Range:&quot;&quot;,///如果暂停了，下次继续开始就用这个，接着上一次的断点继续开始 // }}).then(response =&gt; { if (response.ok) { return response; } else { console.log(&quot;请求失败&quot;) }})// 取出body.then(response =&gt; response.body).then(body =&gt; { const reader = body.getReader(); return new ReadableStream({ start(controller) { function pump() { return reader.read().then(res =&gt; { //res ({ done, value }) const { done, value } = res; if (done) {// 读不到更多数据就关闭流 console.log(&quot;end&quot;) controller.close(); } data=[...data,...value] console.log(&quot;本次请求长度：&quot;,value.length, &quot;--------现在的总长度:&quot;,data.length) // 将下一个数据块置入流中 controller.enqueue(value); return pump(); }); } return pump(); } })}).catch(err =&gt; console.error(err));/*本次请求长度： 1638400 --------现在的总长度: 1638400本次请求长度： 458752 --------现在的总长度: 2097152本次请求长度： 1638400 --------现在的总长度: 3735552...本次请求长度： 509341 --------现在的总长度: 15648157end*/ 大文件上传目前能想到的只有切片。 上面的东西，后面空了在来实现。 主要请求代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193class Errors { static CODE=&quot;code&quot; static MSG=&quot;messgae&quot; static DATA=&quot;data&quot; static ERROR_AUTH_FAILED={[Errors.CODE]:0,[Errors.MSG]:&quot;未登录&quot;} static ERROR_SYSTEM={[Errors.CODE]:500,[Errors.MSG]:&quot;xitongcuowu&quot;} static ERROR_HTTP_TIMEOUT={[Errors.CODE]:500,[Errors.MSG]:&quot;请求超时&quot;} static ERROR_HTTP_CANCEL={[Errors.CODE]:-1,[Errors.MSG]:&quot;请求取消&quot;} static ERROR_BYU(code,msg,data){ return { [Errors.CODE]:code||500, [Errors.DATA]:data, [Errors.MSG]:msg, } }}class Interceptors { ReqHook(config){ config.headers.token=&quot;2222&quot; return config } RespHook(response){ return Promise.resolve(response) }}class Http extends Interceptors { url=&quot;http://127.0.0.1:8080&quot; options={ method: 'GET', // *GET, POST, PUT, DELETE, etc. headers: { 'Content-Type': 'application/json', ///json传值 // 'Content-Type': &quot;application/x-www-form-urlencoded;&quot;, ///表单传值 // 'Content-Type': &quot;multipart/form-data;&quot;, ///表单传值，但是有文件必须用这个， }, cache: 'no-cache', } timeout=30000 controller=null statusVertify(code){return code&lt;=301&amp;&amp;code&gt;=200} constructor(arg){ super(arg) let {uri,data,options,controller}=arg this.url+=uri this.options={...this.options,...options} this.GenerateDefaultController(controller) if(this.options.method===&quot;GET&quot;&amp;&amp;data)this.SetReqQuerry(data) if(this.options.method===&quot;POST&quot;&amp;&amp;data)this.SetReqBody(data) } GenerateDefaultController(controller){ this.controller=controller||new AbortController(); this.options.signal = this.controller.signal; } GetCurData(){ return { url:this.url, options:this.options, timeout:this.timeout, controller:this.controller, } } SetReqQuerry(data){ if(!data)return var querry=&quot;?&quot;,kv=Object.entries(data); if(!kv.length)return kv.forEach(i=&gt;{if(i.length===2)querry+=`${i[0]}=${i[1]}&amp;`}) this.url+=querry.substring(0,querry.length-1) } SetReqBody(data){ switch(this.options.headers[&quot;Content-Type&quot;]){ case &quot;multipart/form-data;&quot;: ///删除了过后浏览器自动拼上Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryZO49FOAdCt8swagX Reflect.deleteProperty(this.options.headers,&quot;Content-Type&quot;) var formData = new FormData(),kv=Object.entries(data); kv.forEach(i=&gt;{if(i.length===2)formData.append(i[0],i[1])}) this.options.body=formData break; case &quot;application/x-www-form-urlencoded;&quot;: var bodyStr=&quot;&quot;,kv=Object.entries(data); if(!data||!kv.length)return kv.forEach(i=&gt;{bodyStr+=`${i[0]}=${i[1]}&amp;`}) this.options.body=bodyStr.substring(0,bodyStr.length-1) break; case &quot;application/json;&quot;: var dataJson=JSON.stringify(data,(key,val)=&gt;{ // TODO .... return val }); this.options.body=dataJson break; } } Do(){ if(!this.ReqHook(this.options))return Promise.reject(Errors.ERROR_AUTH_FAILED) return new Promise((resolve,reject)=&gt;{ const timer = setTimeout(()=&gt;{ this.controller.abort(Errors.ERROR_HTTP_TIMEOUT)},this.timeout) fetch(this.url,this.options) .then(response=&gt;{ Promise.resolve(response.json()).then(data=&gt;{ response.data=data this.RespHook(response) .then(res=&gt;{ if(this.statusVertify(res.status))resolve(res.data) else reject(res.data) }) .catch(res=&gt;{reject(res.data)}) }) }) .catch((err) =&gt; { var error=err if(this.options.signal.aborted)error=this.options.signal.reason reject(error) }) .finally(_=&gt;{clearTimeout(timer)}) }) } Down(){ if(!this.ReqHook(this.options))return Promise.reject(Errors.ERROR_AUTH_FAILED) return new Promise((resolve,reject)=&gt;{ const timer = setTimeout(()=&gt;{ this.controller.abort(Errors.ERROR_HTTP_TIMEOUT)},this.timeout) fetch(this.url,this.options) .then(response=&gt;{ Promise.resolve(response.arrayBuffer()).then(data=&gt;{ response.data=data this.RespHook(response) .then(res=&gt;{ if(this.statusVertify(res.status))resolve(res.data) else reject(res.data) }) .catch(res=&gt;{reject(res.data)}) }) }) .catch((err) =&gt; { var error=err if(this.options.signal.aborted)error=this.options.signal.reason reject(error) }) .finally(_=&gt;{clearTimeout(timer)}) }) } static Request(uri,arg={}){ var {data,options,controller}=arg return new Http({uri,data,options,controller}).Do() } static DownFile(uri,arg={}){ var {data,options,controller}=arg return new Http({uri,data,options,controller}).Down() } static UpFile(uri,arg={}){ var _options={method:&quot;POST&quot;,headers:{&quot;Content-Type&quot;:&quot;multipart/form-data;&quot;}} var {data,options,controller}=arg return new Http({uri,data,options:{...options,..._options},controller}).Do() }} 实际在项目中使用 123456789101112///实际请求是在api.js文件中class Apis{ static Login=(data)=&gt;Http.Request(&quot;/ping&quot;,{data,options:{method:&quot;GET&quot;}}) static UpLoad=(data)=&gt;Http.UpFile(&quot;/upload2&quot;,{data})}//然后在页面中引用import Api from &quot;......&quot;Apis.Login({a:&quot;1&quot;,b:1}).then(res=&gt;{ console.log(res)}) 下面是一些测试的demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162///上传文件// document.querySelector(&quot;#file&quot;).addEventListener(&quot;change&quot;,(e)=&gt;{// Http.UpFile(&quot;/upload2&quot;,{data:{file:e.target.files[0],a:&quot;1&quot;,b:2}}).then(res=&gt;{// console.log(&quot;请求成功&quot;)// console.log(res)// }).catch(e=&gt;{// console.log(&quot;请求错误&quot;)// console.log(e)// })// })///下载文件(下载的是Uint8Array)// Http.DownFile(&quot;/down3&quot;).then(buffer=&gt;{// console.log(&quot;请求成功&quot;)// console.log(buffer)// }).catch(e=&gt;{// console.log(&quot;请求错误&quot;)// console.log(e)// })// Http.Request(&quot;/ping&quot;,{data:{a:&quot;1&quot;,b:2}}).then(res=&gt;{// console.log(&quot;请求成功&quot;)// console.log(res)// }).catch(e=&gt;{// console.log(&quot;请求错误&quot;)// console.log(e)// })// Http.Request(&quot;/post&quot;,{data:{a:&quot;1&quot;,b:2,c:{&quot;t&quot;:1},d:[&quot;4444&quot;,&quot;3333&quot;]},options:{method:&quot;POST&quot;}}).then(res=&gt;{// console.log(&quot;请求成功&quot;)// console.log(res.data)// }).catch(e=&gt;{// console.log(&quot;请求错误&quot;)// console.log(e)// })// Http.Request(&quot;/err&quot;,{data:{a:&quot;1&quot;,b:2,c:{&quot;t&quot;:1},d:[&quot;4444&quot;,&quot;3333&quot;]},options:{method:&quot;POST&quot;}}).then(res=&gt;{// console.log(&quot;请求成功&quot;)// console.log(res.data)// }).catch(e=&gt;{// console.log(&quot;请求错误&quot;)// console.log(e)// })// var controller=new AbortController();// setTimeout(()=&gt;{controller.abort(Errors.ERROR_HTTP_CANCEL)},500)// Http.Request(&quot;/time&quot;,{data:{a:&quot;1&quot;,b:2,c:{&quot;t&quot;:1},d:[&quot;4444&quot;,&quot;3333&quot;]},options:{method:&quot;POST&quot;},controller}).then(res=&gt;{// console.log(&quot;请求成功&quot;)// console.log(res.data)// }).catch(e=&gt;{// console.log(&quot;请求错误&quot;)// console.log(e)// })// Http.Request(&quot;/time&quot;,{data:{a:&quot;1&quot;,b:2,c:{&quot;t&quot;:1},d:[&quot;4444&quot;,&quot;3333&quot;]},options:{method:&quot;POST&quot;}}).then(res=&gt;{// console.log(&quot;请求成功&quot;)// console.log(res.data)// }).catch(e=&gt;{// console.log(&quot;请求错误&quot;)// console.log(e)// })","link":"/2021/01/05/20210105Fetch%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BD%BB%E5%BA%A6%E5%B0%81%E8%A3%85/"},{"title":"小程序ios部分机型格式化时间问题","text":"此代码返回的是NaN 1var leftTime = new Date(&quot;2022-11-11 23:07:00&quot;).getTime() 原因是下面代码返回的是Invlid Date，是因为部分ios的系统（实际是因为某些版本的safari通常不支持DD-MM-YYYY格式）不支持格式化带有 - 符号的时间 1new Date(&quot;2022-11-11 23:07:00&quot;) 解决办法直接替换掉 - 符号为 / 123var endTime=&quot;2022-11-11 23:07:00&quot;let newEndTime = endTime.replace(/\\.|\\-/g, '/')var leftTime = new Date(newEndTime).getTime() 或者直接使用时间戳","link":"/2021/02/28/20210228%E5%B0%8F%E7%A8%8B%E5%BA%8Fios%E9%83%A8%E5%88%86%E6%9C%BA%E5%9E%8B%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/"},{"title":"前端操作excel导入和导出","text":"因业务需要从网页中导出excel文件。 顺便研究了下，导入，编辑，导出，导出带图片的 但是导出带图片的只能是xls文件，导入只能是xlsx文件 如果是vue/react工程项目那么只能在入口文件里面导入 eg：vue-&gt;public-&gt;index.html 文件中直接在head中script引入两个文件,两个脚本放在同级目录(当然你也可以自己创建目录) 1234567&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS读取和导出excel示例&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./exceljs-min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./sheetjs.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 完整实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS读取和导出excel示例&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./exceljs-min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./sheetjs.js&quot;&gt;&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt; table { border-collapse: collapse; } th, td { border: solid 1px #6D6D6D; padding: 5px 10px; } .mt-sm {margin-top: 8px;} body { background: #f4f4f4; padding: 0; margin: 0; } .container { width: 1024px; margin: 0 auto; background: #fff; padding: 20px; min-height: 100vh; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;mt-sm&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; style=&quot;display:none;&quot; accept=&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;/&gt; &lt;a href=&quot;javascript:selectFile()&quot;&gt;加载本地excel文件&lt;/a&gt; &lt;/div&gt; &lt;p&gt;结果输出：（下面表格可直接编辑导出）&lt;/p&gt; &lt;div id=&quot;result&quot; contenteditable&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;导出编辑过后的&quot; onclick=&quot;t0()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;导出纯文本&quot; onclick=&quot;t1()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;导出带图片的&quot; onclick=&quot;t2()&quot;/&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; class ExcelIntance extends ExcelController { constructor(args){ super(args) } //读取本地文件 xlsx inputFiles(files){ if(files.length == 0) return; var f = files[0]; if(!/\\.xlsx$/g.test(f.name)) { alert('仅支持读取xlsx格式！'); return; } super.readWorkbookFromLocalFile(f,(workbook)=&gt;{ //可以做一些操作 this.readWorkbook(workbook); }); } //加载远程的 xlsx loadRemoteFile(url) { super.readWorkbookFromRemoteFile(url, (workbook)=&gt;{ //可以做一些操作. this.readWorkbook(workbook); }); } //导出编辑过后的 exportEditedExcel(title=&quot;导出&quot;) { var el = document.querySelector(`#${this.tagId} table`) var csv = super.table2csv(el); var sheet = super.csv2sheet(csv); var blob = super.sheet2blob(sheet); super.openDownloadDialog(blob, `${title}.xlsx`); } //导出没有图片的excel exportTextExcel(sheet,title=&quot;导出&quot;){super.openDownloadDialog(super.sheet2blob(sheet), `${title}.xlsx`);} //导出带图片的excel exportImgExcel(tHeader,tbody,title=&quot;导出&quot;){export2Excel(tHeader, tbody, title)} } var a= new ExcelIntance({tagId:&quot;result&quot;}) // exportEditedExcel function t0(){ a.exportEditedExcel() } // exportTextExcel function t1(){ var aoa = [ ['主要信息', null, null, '其它信息'], // 特别注意合并的地方后面预留2个null ['姓名', '性别', '年龄', '注册时间'], ['张三', '男', 18, new Date()], ['李四', '女', 22, new Date()] ]; var sheet = XLSX.utils.aoa_to_sheet(aoa); sheet['!merges'] = [ // 设置A1-C1的单元格合并 {s: {r: 0, c: 0}, e: {r: 0, c: 2}} ]; a.exportTextExcel(sheet) } // exportImgExcel function t2(){ let tHeader = [ '鲜花', '颜色', '照片' ] let tbody = [ { name: '玫瑰花', color: '红色', pic: 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2801998497,4036145562&amp;fm=27&amp;gp=0.jpg' }, { name: '桃花花', color: '粉色', pic: 'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=602076004,4209938077&amp;fm=27&amp;gp=0.jpg' } ] a.exportImgExcel(tHeader,tbody) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2021/03/20/20210320%E5%89%8D%E7%AB%AF%E6%93%8D%E4%BD%9Cexcel%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA/"},{"title":"iframe高度根据链入的页面高度自适应","text":"最近突然有个需求是要在页面中的iframe链入其他各种各样的页面。 但是问题来了，实际情况是他不能根据页面内容自适应高度。加了scrolling=“no”过后然后又不能滚动了。页面的其他部分根本展示不出来。 页面的部分代码如下 12345678&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;!-- .... --&gt; &lt;/div&gt; &lt;div class=&quot;content&quot; v-if=&quot;data.src&quot;&gt;&lt;iframe id=&quot;ifr&quot; :src=&quot;data.src&quot; frameborder=&quot;0&quot; height=&quot;&quot; width=&quot;100%&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819202122var timer = nullconst setHeight=()=&gt;{ try { const iframe = document.querySelector('#ifr'); var iframeContext = iframe.contentWindow || iframe.contentDocument.parentWindow; if (iframeContext.document.body) { iframe.height = iframeContext.document.body.scrollHeight; clearInterval(timer) } } catch (error) {}}userStore.data.blogs[route.query.type].forEach(element =&gt; { if(element.adr==route.params.artkey){ data.article=element data.src=`*******` timer=setInterval(setHeight,200) }});onUnmounted(()=&gt;{clearInterval(timer)})","link":"/2021/04/15/20210415iframe%E9%AB%98%E5%BA%A6%E6%A0%B9%E6%8D%AE%E9%93%BE%E5%85%A5%E7%9A%84%E9%A1%B5%E9%9D%A2%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94/"},{"title":"javascript中的原型，原型对象，原型链","text":"原型和原型对象 class的类型为function 12345678///函数A或者 class A {},对应上图左边function A(age,name){ this.age=age this.name=name}var a=new A(1,2)console.log(A.prototype)console.log(A.prototype.constructor===A) proto 和 prototype __proto__（隐式原型）JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过__proto__来访问。ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf()。 __proto__指向的是当前对象的原型对象。换句话说指向创建这个对象的函数的prototype __proto__是每个对象都有的一个属性，函数也可能会有，因为函数也可能是一个实例对象。 prototype（显式原型）每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。 prototype指向的是以——当前函数作为构造函数(上图左边)——构造出来的对象(上图下边)——的原型对象(上图右边)。 1234567function A(age,name){ this.age=age this.name=name}var a=new A(1,2)console.log(A.prototype===a.__proto__)//trueconsole.log(a.__proto__.constructor===A)//true 举个例子js的内置Array 123console.log(Array.prototype)console.log(Array.prototype.constructor===Array)//trueconsole.log(Array.prototype.__proto__===Object.prototype)//true Array.prototype返回的是一个[constructor: ƒ, at: ƒ, concat: ƒ, copyWithin: ƒ, fill: ƒ, …] ，它其实是一个对象，里面有很多方法。 可以看出完美验证了我们上面的流程。 那么出现了个新的Object.prototype是什么呢，继续往下看。 原型链的图解和理解 内置的Object构造器和自己声明的构造器等都是通过内置的Function构造器构造出来的 所以他们都可以看做被内置的Function构造器new出来的实例，所以他们的__proto__都是内置的Function构造器的prototype 但是这些实例的类型为function，且他们拥有__proto__属性。（__proto__对象肯定有，函数可能有，prototype函数有） 当然内置的Function构造器也能当做一个实例","link":"/2021/04/25/20210420js%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E5%AD%A6%E4%B9%A0/"},{"title":"nuxt服务端的打包部署","text":"打包 123456789101112131415161718192021npm run buildnpm run generat如果是想做ssr，那就npm run build，然后npm start把项目服务起起来就行了，如果只是想做静态页面，那就npm run generat，然后通过静态服务器部署server: { port: 3000, // default: 3000 host: '0.0.0.0' // 在服务器上监听所有},所以我采用npm run build打包过后的产物.nuxtstaticpackage.jsonnuxt.config.js 服务器安装node 123yum install nodejs npm -ynode --versionnpm --version 更换npm淘宝源（可跳过）123456789全局配置切换到淘宝源：npm config set registry https://registry.npm.taobao.org全局配置切换到官方源：npm config set registry http://www.npmjs.org检测是否切换到了淘宝源：npm info underscore//安装依赖npm install 启动项目 1npm run start 使用pm2开启进程守护 12345678910111213141516171819202122232425262728npm install pm2 -g安装pm2 update更新版本pm2 list显示所有进程状态pm2 monit监视所有进程pm2 log显示所有进程日志pm2 stop all停止所有进程pm2 restart all重启所有进程pm2 reload all0 秒停机重载进程 (用于 NETWORKED 进程)pm2 stop name停止指定的进程，name为标识pm2 restart name重启指定的进程，name为标识pm2 startup产生 init 脚本 保持进程活着pm2 web运行健壮的 computer API endpoint (http://localhost:9615)pm2 delete name杀死指定的进程，name为标识pm2 delete all杀死全部进程 运行项目 1234pm2 start npm --name &quot;app&quot; -- start//进入到博客运行目录下pm2 start npm --name blog -- startapp是pm2的进程的名字 访问项目 12345678910http://106.52.222.26:3001这里的端口来源于nuxt.config.jsonexport default { server: { // 部署到线上nginx配置 host: '0.0.0.0', port: 3001 }, //......} 注意：如果数据是直接访问的服务器json文件，json文件改变了过后，但是页面中请求数据未改变，重启下进程就好了 pm2 reload all。 举个栗子。他的vuex中，存在一个值(普通的值，不存在什么权限判断啥的)，项目部署的时候不存在，如果接口请求过一次，那么vuex中这个值就已经存在，其他的用户进入页面的时候就不需要请求。","link":"/2021/05/04/20210504nuxt%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2/"},{"title":"构建工具的学习记录","text":"因为公司项目老旧，有很多零散的html文件，老板让我做个优化版，让他们集中起来，易于管理。于是趁此机会学习一下gulp的学习过程 gulp.js 是一个自动化构建工具,用于自动化Web开发中涉及的耗时和重复性任务,Gulp.js 是基于 Node.js 构建的,利用 Node.js 流的威力,你可以快速构建项目。 先放上官网 http://www.gulpjs.com.cn/docs/getting-started/quick-start/ 然后在百度一波流的概念。 流（Stream）不是 gulp 创造的概念，而是从 unix 时代就开始使用的 I/O 机制，一直到现在仍在广泛使用。Node 封装了一个 stream 模块专门用来对流进行操作。gulp 所基于的流即是 Node 封装起来的 stream。上面 gulp.task() 代码里面的 pipe 方法并不是 gulp 提供的 api，而是 node 的 api，准确的说应该是 node 的 stream 模块提供的 api。具体是怎么实现的呢： gulp.src() 的返回值是 node Stream 的一个实例，之后的 pipe 调用的其实是这个实例的 pipe 方法，而 pipe 方法的返回值依然是 node Stream 实例，以此实现前面的 .pipe().pipe().pipe() 这种串联写法。熟悉 jQuery 的同学应该很清楚这种技巧。 下表是从各个角度对 gulp 和 webpack 做的对比(当然构建化工具有很多，这里只比较了两个)： Syntax Description 定位 基于流的自动化构建工具 一个万能模块打包器 目标 自动化和优化开发工作流，为通用 website 开发而生 通用模块打包加载器，为移动端大型 SPA(单页应用) 应用而生 学习难度 易于学习，易于使用，api总共只有5个方法 有大量新的概念和api，不过好在有详尽的官方文档 适用场景 基于流的作业方式适合多页面应用开发 一切皆模块的特点适合单页面应用开发 作业方式 对输入（gulp.src）的 js，ts，scss，less 等源文件依次执行打包（bundle）、编译（compile）、压缩、重命名等处理后输出（gulp.dest）到指定目录中去，为了构建而打包 对入口文件（entry）递归解析生成依赖关系图，然后将所有依赖打包在一起，在打包之前会将所有依赖转译成可打包的 js 模块，为了打包而构建 使用方式 常规 js 开发，编写一系列构建任务（task） 编辑各种 JSON 配置项 优点 适合多页面开发，易于学习，易于使用，接口优雅。 可以打包一切资源，适配各种模块系统 缺点 在单页面应用方面输出乏力，而且对流行的单页技术有些难以处理（比如 Vue 单文件组件，使用 gulp 处理就会很困难，而 webpack 一个 loader 就能轻松搞定） 不适合多页应用开发，灵活度高但同时配置很繁琐复杂。“打包一切” 这个优点对于 HTTP/1.1 尤其重要，因为所有资源打包在一起能明显减少浏览器访问页面时的资源请求数量，从而减少应用程序必须等待的时间。但这个优点可能会随着 HTTP/2 的流行而变得不那么突出，因为 HTTP/2 的多路复用可以有效解决客户端并行请求时的瓶颈问题。 结论 浏览器多页应用(MPA)首选方案 浏览器单页应用(SPA)首选方案 我看好多人说 gulp 和 webpack 不是一类东西，我不这么觉得，虽然说两者的出发点确实是不一样的，gulp 走的是流式处理路线，webpack 走的是模块处理路线，但是两者所要达成的目标却是一样的，那就是促进前端领域的自动化和工程化管理。webpack 发展到现在，已经非常强大了，强大到在构建方面 gulp 能做的事 webpack 基本上都可以胜任，gulp 做不了的 webpack 也能搞。同样的那些开发工作中痛苦又耗时的任务，gulp 和 webpack 都能解决，只是解决思路有天壤之别。gulp 和 webpack 只是我们解决问题的工具，不要被工具束缚了手脚不能前进。 | 全局安装 12cnpm i -g gulp//全局安装是为了执行你所编写的 gulp 任务，如gulp yourTask 初始化项目 123456789//初始化npm init//安装gulp，本地安装，是为了咱们编写任务时使用 gulp 提供的 api，例如 gulp.src()cnpm i --save-dev gulp //或者 -D//主目录下创建 gulpfile.js 核心文件学习历程如下(更加详细的使用查看官网) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242//cnpm i -D gulp-cssmin //替换css空格的插件//cnpm i -D gulp-autoprefixer //给样式添加前缀，为了兼容浏览器/* 把配置写在package.json 里面 eg &quot;browserslist&quot;:[&quot;last 5 versions&quot;] Replace Autoprefixer browsers option to Browserslist config. Use browserslist key in package.json or .browserslistrc file. Using browsers option can cause errors. Browserslist config can be used for Babel, Autoprefixer, postcss-normalize and other tools. If you really need to use option, rename it to overrideBrowserslist. Learn more at: https://github.com/browserslist/browserslist#readme https://twitter.com/browserslist*///cnpm i -D gulp-sass //打包sass 提示python啥的 那是版本没对//cnpm i -D gulp-uglify //压缩打包js//cnpm i -D gulp-babel //es6 转 es5 gulp-babel@8用的gulp4 gulp-babel@7用的gulp3 同时还依赖下面两个//cnpm i -D @babel/core//cnpm i -D @babel/preset-env//cnpm i -D gulp-htmlmin //压缩html 参数详情看文档https://github.com/kangax/html-minifier//cnpm i -D del //清楚上次打包的文件 &lt;!--不是流，直接执行这个函数--&gt;//cnpm i -D gulp-webserver //本地服务器 https://www.npmjs.com/package/gulp-webserver//cnpm i -D gulp-imagemin //压缩图片 因为要保证无损，大多时候不压缩//cnpm i -D gulp-file-include //组件打包，把一个html当成一个片段打到另一个组件里面//有些东西不需要打包，比如 fonts ....const gulp = require(&quot;gulp&quot;)const cssmin = require(&quot;gulp-cssmin&quot;)const autoprefixer = require(&quot;gulp-autoprefixer&quot;)const sass = require(&quot;gulp-sass&quot;)(require(&quot;node-sass&quot;))const uglify = require(&quot;gulp-uglify&quot;)const babel = require(&quot;gulp-babel&quot;)const htmlMin = require(&quot;gulp-htmlmin&quot;)const del = require(&quot;del&quot;)const webserver = require(&quot;gulp-webserver&quot;)const fileInclude = require(&quot;gulp-file-include&quot;)//打包cssconst cssompress = function(){ // gulp.src(&quot;./src/**/*&quot;) return gulp .src(&quot;./src/css/*.css&quot;) .pipe(autoprefixer()) .pipe(cssmin()) .pipe(gulp.dest(&quot;./dist/css/&quot;))}//打包scssconst sassHandler = function(){ // gulp.src(&quot;./src/**/*&quot;) return gulp .src(&quot;./src/css/*.scss&quot;) .pipe(sass()) .pipe(autoprefixer()) .pipe(cssmin()) .pipe(gulp.dest(&quot;./dist/css/&quot;))}//打包jsconst jsHandler = function(){ return gulp .src(&quot;./src/js/*.js&quot;) .pipe(babel({ presets:[&quot;@babel/env&quot;] })) .pipe(uglify()) .pipe(gulp.dest(&quot;./dist/js/&quot;))}//打包htmlconst htmlHandler = function(){ return gulp .src(&quot;./src/page/*.html&quot;) //打包组件 .pipe(fileInclude({ prefix:&quot;@#@&quot;,//定义的一个标识符 basepath:&quot;./src/components&quot;,//组件存放的目录 /* 使用 ： @#@include(&quot;./header.html&quot;) 给组件传值 @#@include(&quot;./header.html&quot;,{data:&quot;1&quot;,name:&quot;header&quot;}) 组件 &lt;div&gt;@#@data&lt;/div&gt; &lt;div&gt;@#@header&lt;/div&gt; */ })) .pipe(htmlMin({ collapseWhitespace:true,//移除空格 removeEmptyAttributes:true,//移除空属性(自定义属性不行，原生的) collapseBooleanAttributes:true,//合并bool为true的属性 ，比如checked=&quot;checked&quot; =&gt; checked removeAttributeQuotes:true,//比如 class=&quot;a&quot; -&gt; class=a class=&quot;a b&quot;则不行 minifyCSS:true,//压缩style标签的代码(基本压缩，所以最好外联) minifyJS:true,//压缩js标签的代码(基本压缩，所以最好外联) removeScriptTypeAttributes:true,//type=&quot;text/javascript&quot;从script标签中删除。其他type属性值保持不变 removeStyleLinkTypeAttributes:true,//type=&quot;text/css&quot;从style和link标签中删除。其他type属性值保持不变 //其他看文档 })) .pipe(gulp.dest(&quot;./dist/page/&quot;))}//导出图片const imgHandler = function(){ return gulp .src(&quot;./src/assets/*&quot;) .pipe(gulp.dest(&quot;./dist/assets/&quot;))}//打包一个第三方任务const libHandler = function(){ return gulp .src(&quot;./src/lib/**/*&quot;) .pipe(gulp.dest(&quot;./dist/lib/&quot;))}//删除方任务const delHandler = function(){ //传如数组(你要删除的目录) return del([&quot;./dist/&quot;])}//删除方任务const webserverHandler = function(){ //传如数组(你要删除的目录) return gulp .src(&quot;./dist&quot;) .pipe(webserver({ host:&quot;localhost&quot;, /* 如果你这里是自定义,假如 www.tabby.com 找到 C:\\Windows\\System32\\drivers\\etc\\hosts 末尾加上 127.0.0.1 www.tabby.com */ port:&quot;9527&quot;, livereload:true,//默认你修改dist下面的文件才会刷新,但是要修改dist那么只能重新打包 open:true,//自动打开浏览器 fallback: './page/index.html',//默认打开的路径(根目录是上面的dist proxies:[ /* 每一个代理都是一个对象，不要写空对象 http://localhost:9000/geta/cors 跨域错误的地址 http://localhost:9000/ 代理地址 /proxytest/geta/cors 200 http://localhost:9000/geta/cors 跨域错误的地址 http://localhost:9000/geta/ 代理地址 /proxytest/cors 200 */ { source: '/proxytest',//代理标识符号 target: 'http://localhost:9000/geta/',//代理地址 // options: { // headers: { // 'ABC_HEADER': 'abc', // }, // }, } ] }))}//监控任务const watchHandler = function(){ gulp.watch(&quot;./src/css/*&quot;,sassHandler)}module.exports.cssompress=cssompressmodule.exports.sassHandler=sassHandlermodule.exports.jsHandler=jsHandlermodule.exports.htmlHandler=htmlHandlermodule.exports.imgHandler=imgHandlermodule.exports.delHandler=delHandlermodule.exports.webserverHandler=webserverHandler/* 配置一个默认任务，把上面的一起执行了 1. gulp.task(&quot;defalut&quot;,()=&gt;{}) 2. module.exports.default=()=&gt;{} 3. 如下 当然你也可以叫abc那么执行 gulp abc,如果是default,那么可以只执行gulp就OJ*/// module.exports.default=gulp.parallel(cssompress,sassHandler,jsHandler,htmlHandler,imgHandler)/* 删除任务 比如你这次css文件夹里只有一个b.css文件删除了上次的a.css， 那么你下次打包dist/css文件路径下a.css还是存在 */// module.exports.default=gulp.series(// delHandler,// gulp.parallel(cssompress,sassHandler,jsHandler,htmlHandler,imgHandler)// )/* 用gulp启动一个服务 src： html引用的是一个stylusScss.css文件 因为不存在所以会报错 dist： html引用的是一个stylusScss.css文件 因为stylusScss.scss被转成了css文件所以没问题*/// module.exports.default=gulp.series(// delHandler,// gulp.parallel(cssompress,sassHandler,jsHandler,htmlHandler,imgHandler),// webserverHandler,// )/* 监控任务*/module.exports.default=gulp.series( delHandler, gulp.parallel(cssompress,sassHandler,jsHandler,htmlHandler,imgHandler), webserverHandler, watchHandler)","link":"/2021/04/25/20210425gulp%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"有关parseInt第二个参数的一些问题","text":"最近在网上看了一个面试题，如下 1234[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(parseInt)parseInt(&quot;1&quot;,0)parseInt(&quot;2&quot;,1)parseInt(&quot;3&quot;,2) 相信答案不必多说 1[1,NaN,NaN] 那么问题来了，经过计算，2通过一进制解析是能得到数字的，3通过二进制解析也是是能得到数字的，为什么会是NaN呢？ 分析如下： parseInt(“3”,2)基数为2，合适的数字为0,1，但是3大于0和1，所以返回为NaN; 我又尝试了一些其他的数字，发现问题不止如此，出现了如下情况 12345parseInt(&quot;16&quot;,2) //1parseInt(&quot;18&quot;,2) //1parseInt(&quot;19&quot;,2) //1parseInt(&quot;195&quot;,2) //1parseInt(&quot;95&quot;,2) //NaN 因为基数为2，合适的数字只有0,1，所以走到了9或者8或者6就不会往后面继续解析直接返回，解析就停止了，实际解析的只有1，实际是在执行parseInt(“1”,2) 如果第一个都不符合那么直接返回NaN 123parseInt('dsff984',16) // 13parseInt('d66',16) // 3430parseInt('ddff984',16) // 14548838 因为十进制最大的数字是9,但是到了十一进制往上，最大的数字是两位数了，这当然不行，所以从10开始往上，就用字母代替。 a==10,b==11,c=12,d=13 …… z==35；所以parseInt的第二个参数必须要规定在2~36之间。注意还有个一进制 再看看上面这道问题，在16进制中，最大的数字是15，对应字母也就是f，超过f的字母也就超出了16进制的解析范围。 ‘dsff984’的第一个字符是d，也就是十进制中的13，第二个字符s，代表十进制中的28，这显然超出了16进制的解析范围，所以s和它之后的字符都会被parseInt自动忽略，所以我们得到13。‘d66’的第一个字符是d，也就是十进制中的13，(1316²)+(616)+(6*16°)=3430‘ddff984’ 参照上面 **parseInt(x,y)将y进制数x转化成普通数字(十进制)**如果x不是一个合格的y进制数就会采取措施，导致上面的情况，多提一句parseFloat只接受一个参数，只能使用十进制去解析。","link":"/2021/07/05/20210705%E6%9C%89%E5%85%B3parseInt%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"title":"前端对二进制深入剖析","text":"自我感觉一直对浏览器的二进制操作比,文件操作,以及其他的io读写等较迷糊。今天开个专场彻底搞清。 blobBlob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。Blob对象本质上是js中的一个对象，里面可以储存大量的二进制编码格式的数据，我们不可以直接操作他。 构造函数var aBlob = new Blob( array, options ); array .可以是如下 ArrayBuffer ArrayBufferView Blob DOMString(DOMStrings 会被编码为 UTF-8。) options 是一个可选的BlobPropertyBag字典，它可能会指定如下两个属性 type，默认值为 “”，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。 endings，默认值为”transparent”，用于指定包含行结束符\\n的字符串如何被写入。它是以下两个值中的一个：”native”，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 “transparent”，代表会保持 blob 中保存的结束符不变 非标准123456789101112131415161718192021222324var aFileParts = ['&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey!&lt;/b&gt;&lt;/a&gt;']; // 一个包含 DOMString 的数组var oMyBlob = new Blob(aFileParts, {type : 'text/html'}); // 得到 blobconst obj = {hello: '我tm看看行不行'};const blob = new Blob([JSON.stringify(obj)],{type:'application/json'});var ab = new ArrayBuffer(32);var blob = new Blob([ab]); // 注意必须包裹[]//base64转Blobfunction dataURLtoBlob(base64Str) {// data:image/jpeg;base64,/9j/4AAQSkZJR... var arr =base64Str.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), //atob() //ASCII to Base64 , btoa() //Base64 to ASCII n = bstr.length, u8arr = new Uint8Array(n); while (n--) { u8arr[n] = bstr.charCodeAt(n); } return new Blob([u8arr], { type: mime });}//还有读出的文件 demo12const obj = {hello: '我tm看看行不行'};const blob = new Blob([JSON.stringify(obj)],{type:'application/json'}); 属性 Blob.prototype.size 只读。Blob 对象中所包含数据的大小（字节）。 Blob.prototype.type 只读。一个字符串，表明该 Blob 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。12console.log(blob.size)console.log(blob.tpye) 方法 Blob.prototype.text() 返回一个 promise，其会兑现一个包含 Blob 所有内容的 UTF-8 格式的字符串。12blob.text().then(t=&gt;console.log(t)){&quot;hello&quot;:&quot;我tm看看行不行&quot;} Blob.prototype.slice() 返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。123var b=blob.slice(0,18)b.text().then(t=&gt;console.log(t)){&quot;hello&quot;:&quot;我tm看 Blob.prototype.arrayBuffer() 返回一个 promise，其会兑现一个包含 Blob 所有内容的二进制格式的 ArrayBuffer （下面详解）。123var bufferPromise = blob.arrayBuffer();blob.arrayBuffer().then(buffer =&gt; /* 处理 ArrayBuffer 数据的代码……*/);var buffer = await blob.arrayBuffer(); Blob.prototype.stream() 返回一个能读取 Blob 内容的 ReadableStream。123456var stream= blob.stream()console.log(stream)Promise.resolve(new Response(stream,{headers:{'Content-Type':'text/html' }}).text()).then(text=&gt;{ console.log(text)}) File1234567891011121314151617181920212223242526&lt;input type=&quot;file&quot; id=&quot;file&quot;&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; id=&quot;img&quot;&gt;&lt;script&gt; document.querySelector(&quot;#file&quot;).addEventListener(&quot;change&quot;, function (File) { console.log(File.target.files[0]) getFile(File.target.files[0]) }) function getFile(File) { console.log(File.lastModified) //返回当前 File 对象所引用文件最后修改时间，自 UNIX 时间起始值（1970 年 1 月 1 日 00:00:00 UTC）以来的毫秒数。 console.log(File.lastModifiedDate) //返回当前 File 对象所引用文件最后修改时间的 Date 对象。 console.log(File.name) //返回当前 File 对象所引用文件的名字。 console.log(File.size) //返回文件的大小。 console.log(File.webkitRelativePath)//返回 File 相关的 path 或 URL。 console.log(File.type) //返回文件的 多用途互联网邮件扩展类型（MIME Type）由第三个参数中的type决定 ///File 接口没有定义任何方法，但是它从 Blob 接口继承了以下方法 console.log(File.slice(0, 1000))// }&lt;/script&gt;1664593283489Sat Oct 01 2022 11:01:23 GMT+0800 (中国标准时间)1.jpg123637image/jpegBlob {size: 1000, type: ''} FileReader12345678910var File = new File([],&quot;./imgs/1.jpg&quot;,{type:&quot;image/jpg&quot;})function printFile(file) { var reader = new FileReader(); reader.onload = function(evt) { console.log(evt); console.log(reader.error); console.log(reader.readyState);//0还没有加载任何数据。1数据正在被加载。2已完成全部的读取请求。 console.log(reader.result);///===evt.target.result };} readAsArrayBuffer(blob/File)1234ProgressEvent {isTrusted: true, lengthComputable: true, loaded: 123637, total: 123637, type: 'load', …}null2ArrayBuffer(123637) 1234ProgressEvent {isTrusted: true, lengthComputable: true, loaded: 123637, total: 123637, type: 'load', …}null2ArrayBuffer(123637) readAsBinaryString(blob/File) 该特性是非标准的，请尽量不要在生产环境中使用它！ readAsDataURL(blob/File) 读出base641234ProgressEvent {isTrusted: true, lengthComputable: true, loaded: 2233, total: 2233, type: 'load', …}null2data:application/octet-stream;base64,/u3+7QAAAAIAAAABAAAAAQAGMTIzNDU2AAABc1Z= readAsText(blob/File) 读出字符串 ArrayBufferArrayBuffer表示二进制数据的原始缓冲区，用于存储不同类型化数组的数据。我们无法直接读取或写入 ArrayBuffer，但是可以根据需要将其传递到类型化数组 TypedArray 或 DataView 视图来操作二进制数据 浏览器中以现有数据获取 ArrayBuffer 或者创建一个空buffer 1234567891011const obj = {hello: '我tm看看行不行'};const blob = new Blob([JSON.stringify(obj)],{type:'application/json'});console.log(blob.buffer)var b0 = Buffer.from('bwGO8X5gdaM5dsV@');console.log(b0)var arr = [0x15,0xFF,0x01,0x00,0x34,0xAB,0x11];var u8 = new Uint8Array(arr);var ab = u8.buffer;console.log(ab); // ab为要解析的ArrayBuffer 以其他现有数据获取查看文档MDN传送门 length，缓冲区的长度，每个字节的值默认都是0。如果无法分配请求数目的字节，则将引发异常。 byteLength。 只读属性，用于获取到ArrayBuffer实例的长度（以字节为单位）。 如果分配的内存较大，可能会分配失败，所以可以通过校验长度来判断是否分配成功。 slice()。将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象，与blob的slice方式类似。除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图进行读写。 isView()。这是个静态方法！返回一个布尔值。表示参数是否为ArrayBuffer的视图实例，即是否为TypedArray或DataView实例。12345678910111213var buffer = new ArrayBuffer(8);ArrayBuffer.isView(buffer) // falsevar file = document.getElementById(&quot;file&quot;).files[0];var reader = new FileReader();reader.readAsArrayBuffer(file)reader.onload = function (e) { var data = e.target.result; ArrayBuffer.isView(data) // false}var i32 = new Int32Array(buffer);ArrayBuffer.isView(i32) // true ReadableStreamReadableStream这个用的不是很我也只是了解下，做个记录，需要的时候在回来看看文档。😳 流操作API中的ReadableStream 接口呈现了一个可读取的二进制流操作。 ReadableStream.locked。一个可读流最多可以有一个激活的 reader，并且直到被释放之前都是锁定到该 reader。可以使用 ReadableStream.getReader() 方法获取 reader 然后使用 reader 的 releaseLock() 方法释放可读流。1234const stream = new ReadableStream({...});const reader = stream.getReader();console.log(stream.locked)// 应返回 true，表示流已经锁定到了一个 reader getReader() 接口的 getReader() 方法会创建一个 reader，并将流锁定。只有当前 reader 将流释放后，其他 reader 才能使用。 cancel() 用于在不再需要来自它的任何数据的情况下（即使仍有排队等待的数据块）完全结束一个流。 pipeThrough() 方法提供了一种链式的方式，将当前流通过转换流或者其它任何一对可写/可读的流进行管道传输。 pipeTo() 方法通过管道将当前的 ReadableStream 中的数据传递给给定的 WritableStream 并且返回一个 Promise，promise 在传输成功完成时兑现，在遇到任何错误时则会被拒绝。 tee() 方法对当前的可读流进行拷贝（tees），返回包含两个 ReadableStream 实例分支的数组。简单示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859fetch('http://127.0.0.1:8080/ping').then((response) =&gt; { // response.text().then(res=&gt;{console.log(res)})//可以直接取值，但是下面要演示 console.log(response) /* body: ReadableStream bodyUsed: true headers: Headers {} ok: true redirected: false status: 200 statusText: &quot;OK&quot; type: &quot;cors&quot; url: &quot;http://127.0.0.1:8080/ping&quot; */ return response.body}).then((body) =&gt; { const reader = body.getReader();///这里的body本身就是一个ReadableStream console.log(reader) /* closed: Promise {&lt;fulfilled&gt;: undefined} [[Prototype]]: ReadableStreamDefaultReader */ //构造一个新的ReadableStream const newReadableStream=new ReadableStream({ start(controller) { console.log(controller) /* desiredSize: 0 [[Prototype]]: ReadableStreamDefaultController */ function push() { reader.read().then(({ done, value }) =&gt; { if (done) { console.log('写入流完成', done); controller.close();///关闭此流 return; } console.log(&quot;开始写入流&quot;) controller.enqueue(value);///将给定的块排入关联的流。 console.log(done, value); push();///在执行一次，如果已经完成则关闭此流 }); } push();///开始从body的流写入此流 }, }); return newReadableStream}).then((stream) =&gt; { console.log(stream) /* locked: false [[Prototype]]: ReadableStream */ return new Response(stream, {headers:{'Content-Type':'text/html'}}).text();}).then((result) =&gt; { console.log(result); });///{&quot;message&quot;:&quot;pong&quot;} TypedArrayArrayBuffer对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view）。ArrayBuffer有两种视图，一种是 TypedArray视图，另一种是DataView视图。前者的数组成员都是同一种数据类型，后者的数组成员可以是不同种的数据类型。 TypedArray视图共有9种类型，每一种视图都是一种构造函数。 名称 类型 大小 Int8Array 8位有符号整型 长度1个字节 Uint8Array 8位无符号整型 长度1个字节 Uint8ClampedArray 8位无符号整型 长度1个字节，溢出取极值 Int16Array 16位有符号整型 长度2个字节。 Uint16Array 16位无符号整型， 长度2个字节。 Int32Array 32位有符号整型 长度4个字节 Uint32Array 32位无符号整型 长度4个字节 Float32Array 32位浮点型 长度4个字节 Float64Array 64位浮点型 长度8个字节 区别这几个构造函数生成的实例都是类数组。 也都是有length属性（注意与byteLength区分） 都能用取下标的方式（[]）获取单个数据， 所有数组的方法（无contact方法）都能使用。 普通数组与TypedArray类数组的差异主要在以下方面。 TypedArray数组中所有成员，都是同一种类型的。 TypedArray数组的成员是连续的，不会有空位。 TypedArray数组成员的默认值为0。比如，new Array(10)返回一个普通数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个TypedArray数组，里面10个成员都是0。 TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性（prototype）。 TypedArray构造函数。这九种构造函数，可以生产不同类型的数据实例。 TypedArray(buffer, byteOffset, length)。 byteOffset必须与所要建立的数据类型一致，否则会报错。 同一个TypedArray中，可以建立多个不同的数据视图。 buffer（必需）：视图对应的底层ArrayBuffer对象。 byteOffset（可选）：视图开始的字节序号，默认从0开始。 length（可选）：视图包含的数据个数，默认直到本段内存区域结束。12345678// 创建一个8字节的ArrayBuffervar b = new ArrayBuffer(8);// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾 var v1 = new Int32Array(b);// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾 var v2 = new Uint8Array(b, 2);// 创建一个指向b的Int16视图，开始于字节2，长度为2 var v3 = new Int16Array(b, 2, 2); TypedArray(length)。还可以通过直接 new 构造函数的方式直接使用。1234var fa64 = new Float64Array(8);fa64[0] = 10;fa64[1] = 20;fa64[2] = fa64[0] + fa64[1]; TypedArray(typedArray)。参数也可以是其他 typedArray。注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。如果想基于同一段内存，构造不同的视图，可以采用下面的写法。12345678910111213141516171819var typedArray = new Int8Array(new Uint8Array(4));//理解如下var x = new Int8Array([1, 1]);var y = new Int8Array(x);x[0]y[0]x[0] = 2;y[0]// 如果想基于同一段内存，构造不同的视图，可以采用下面的写法。var x = new Int8Array([1, 1]);var y = new Int8Array(x.buffer);x[0]y[0]x[0] = 2;y[0] TypedArray(arrayLikeObject)。构造函数的参数也可以是一个普通数组，TypedArray 数组也可以转换回普通数组。12var typedArray = new Uint8Array([1, 2, 3, 4]);var normalArray = Array.prototype.slice.call(typedArray); BYTES_PER_ELEMENT 属性。每一种视图的构造函数，都有一个 BYTES_PER_ELEMENT 属性，表示这种数据类型占据的字节数。这个属性在 TypedArray 实例上也能获取，即有 TypedArray.prototype.BYTES_PER_ELEMENT。 12345678Int8Array.BYTES_PER_ELEMENTUint8Array.BYTES_PER_ELEMENTInt16Array.BYTES_PER_ELEMENTUint16Array.BYTES_PER_ELEMENTInt32Array.BYTES_PER_ELEMENTUint32Array.BYTES_PER_ELEMENTFloat32Array.BYTES_PER_ELEMENTFloat64Array.BYTES_PER_ELEMENT TypedArray 原型属性 TypedArray.prototype.buffer。前面我们也用到了，返回整段内存区域对应的 ArrayBuffer 对象。该属性为只读属性。视图对象和 b 视图对象，对应同一个 ArrayBuffer 对象，即同一段内存。12var a = new Float32Array(64);var b = new Uint8Array(a.buffer); TypedArray.prototype.length。该属性表示 TypedArray 数组含有多少个成员。注意将 byteLength 属性和 length 属性区分，前者是字节长度，后者是成员长度。123var a = new Int16Array(90);a.length // 90 a.byteLength // 180 TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset。byteLength 属性返回 TypedArray 数组占据的内存长度，单位为字节。byteOffset 属性返回 TypedArray 数组从底层 ArrayBuffer 对象的哪个字节开始。这两个属性都是只读属性。12345678910111213var b = new ArrayBuffer(8);var v1 = new Int32Array(b);var v2 = new Uint8Array(b, 2);var v3 = new Int16Array(b, 2, 2);v1.byteLength // 8v2.byteLength // 6v3.byteLength // 4v1.byteOffset // 0v2.byteOffset // 2v3.byteOffset // 2 TypedArray.prototype.set()。TypedArray 数组的 set 方法用于复制数组（普通数组或 TypedArray 数组），也就是将一段内容完全复制到另一段内存。set 方法还可以接受第二个参数，表示从 b 对象的哪一个成员开始复制 a 对象。它是整段内存的复制，比一个个拷贝成员的那种复制快得多。1234var a = new Uint16Array(8);var b = new Uint16Array(10);b.set(a, 2) TypedArray.prototype.subarray()。subarray 方法是对于 TypedArray 数组的一部分，再建立一个新的视图。12345var a = new Uint16Array(8);var b = a.subarray(2,3);a.byteLengthb.byteLength TypedArray.prototype.slice()。类似于数组的 slice 方法，可以返回一个指定位置的新的 TypedArray 实例。12let ui8 = Uint8Array.of(0, 1, 2);ui8.slice(-1) TypedArray.of()。该方法用于将参数转为一个 TypedArray 实例。 TypedArray.from()。静态方法 from 接受一个可遍历的数据结构（比如数组）作为参数，返回一个基于这个结构的 TypedArray 实例。 溢出问题有一种特殊的 Uint8ClampedArray 类型，凡是发生正向溢出，该值一律等于当前数据类型的最大值，即 255；如果发生负向溢出，该值一律等于当前数据类型的最小值，即 0。 12345678910111213141516var uint8c = new Uint8ClampedArray(1);uint8c[0] = 256;uint8c[0]uint8c[0] = -1;uint8c[0]而另外的其他类型，都会出现溢出情况，var int8 = new Int8Array(1);int8[0] = 128;int8[0]int8[0] = -129;int8[0] 复合视图 由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据，这叫做 “复合视图”。下面代码将一个 24 字节长度的 ArrayBuffer 对象，分成三个部分，字节 0 到字节 3 是 1 个 32 位无符号整数，字节 4 到字节 19 是 16 个 8 位整数，字节 20 到字节 23 是 1 个 32 位浮点数。 1234var buffer = new ArrayBuffer(24);var idView = new Uint32Array(buffer, 0, 1);var usernameView = new Uint8Array(buffer, 4, 16);var amountDueView = new Float32Array(buffer, 20, 1); 如果一段数据包括多种类型（比如服务器传来的 HTTP 数据），这时除了建立 ArrayBuffer 对象的复合视图以外，还可以通过 DataView 视图进行操作。 DataView 视图本身也是构造函数，接受一个 ArrayBuffer 对象作为参数，生成视图。 DataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]); 12var buffer = new ArrayBuffer(24);var dv = new DataView(buffer); DataView 实例有以下属性，含义与 TypedArray 实例的同名方法相同。 DataView.prototype.buffer：返回对应的 ArrayBuffer 对象 DataView.prototype.byteLength：返回占据的内存字节长度 DataView.prototype.byteOffset：返回当前视图从对应的 ArrayBuffer 对象的哪个字节开始 DataView 实例提供 8 个方法读取内存。 getInt8：读取 1 个字节，返回一个 8 位整数。 getUint8：读取 1 个字节，返回一个无符号的 8 位整数。 getInt16：读取 2 个字节，返回一个 16 位整数。 getUint16：读取 2 个字节，返回一个无符号的 16 位整数。 getInt32：读取 4 个字节，返回一个 32 位整数。 getUint32：读取 4 个字节，返回一个无符号的 32 位整数。 getFloat32：读取 4 个字节，返回一个 32 位浮点数。 getFloat64：读取 8 个字节，返回一个 64 位浮点数。 这一系列 get 方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。 123456789var buffer = new ArrayBuffer(24);var dv = new DataView(buffer);var v1 = dv.getUint8(0);var v2 = dv.getUint16(1);var v3 = dv.getUint16(3); 如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView 的 get 方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在 get 方法的第二个参数指定 true。 12345var v1 = dv.getUint16(1, true);var v2 = dv.getUint16(3, false);var v3 = dv.getUint16(3); DataView 视图提供 8 个方法写入内存。 setInt8：写入 1 个字节的 8 位整数。 setUint8：写入 1 个字节的 8 位无符号整数。 setInt16：写入 2 个字节的 16 位整数。 setUint16：写入 2 个字节的 16 位无符号整数。 setInt32：写入 4 个字节的 32 位整数。 setUint32：写入 4 个字节的 32 位无符号整数。 setFloat32：写入 4 个字节的 32 位浮点数。 setFloat64：写入 8 个字节的 64 位浮点数。这一系列 set 方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false 或者 undefined 表示使用大端字节序写入，true 表示使用小端字节序写入。12345678910111213dv.setInt32(0, 25, false);dv.setInt32(4, 25);dv.setFloat32(8, 2.5, true);//如果不确定正在使用的计算机的字节序，可以采用下面的判断方式var littleEndian = (function() { var buffer = new ArrayBuffer(2); new DataView(buffer).setInt16(0, 256, true); return new Int16Array(buffer)[0] === 256;})();","link":"/2021/06/01/20210601%E5%89%8D%E7%AB%AF%E5%AF%B9%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/"},{"title":"HTTP的进阶和理解","text":"GET和POST请求的区别 长度限制：GET会限制长度,POST不会 实际上 HTTP 协议规范并没有对 GET 方法请求的 url 长度进行限制，是浏览器及服务器的限制。 IE大约2083个字符，chrome大约 8192 个字符，其他浏览器大于 8192 个字符。主流的服务器对 get 方法中 url 的长度限制也大于等于8192个字符。 应用场景： GET 用于获取数据, POST 用于提交数据 安全性： GET 将参数放入 url 中，不太安全，因为url 会被保留在历史记录中。 报文格式： GET 请求的报文中实体部分为空，POST 请求的报文中实体部分为向发送的数据。 请求长度： GET 请求发送数据时的长度会根据浏览器的限制而不同。 是否缓存： 浏览器一般会对 GET 请求缓存，但很少对 POST 请求缓存。 参数类型： POST 的参数传递支持更多的数据类型。 HTTP，HTTP1.0，HTTP2.0 的部分区别超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，利用 SSL/TLS 来加密数据包。HTTPS 的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。 安全层的主要职责就是对发起的 HTTP 请求的数据进行加密操作和对接收到的HTTP的内容进行解密操作。 HTTPS是如何保证安全的结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。此时⼜带来⼀个问题，中间⼈问题： 如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的 Hash 算法、证书到期时间等。 但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。 数字签名就是⽤ CA ⾃带的 Hash 算法对证书的内容进⾏ HASH 得到⼀个摘要，再⽤ CA 的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的 Hash 算法,再次⽣成消息摘要，然后⽤ CA 的公钥对数字签名解密,得到 CA 创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。 HTTP，HTTP1.0，HTTP2.0 的部分区别队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。 HTTP和HTTPS请求的区别 HTTP 协议信息是明文传输的，HTTPS 则是具有安全性的 SSL 加密传输协议； HTTP 协议端口是 80，HTTPS 协议端口是 443； HTTP 协议连接很简单，是无状态的；HTTPS 协议是有 SSL 和 HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 更加安全。 HTTP状态码 类别 原因 描述 1xx Informational(信息性状态码) 接受的请求正在处理 2xx Success(成功状态码) 请求正常处理完毕 3xx Redirection(重定向状态码) 需要进行附加操作一完成请求 4xx Client Error (客户端错误状态码) 服务器无法处理请求 5xx Server Error(服务器错误状态码) 服务器处理请求出错 200 OK 表示客户端发来的请求被服务器端正常处理了。 204 No Content 表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。 206 Partial Content 表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。 301 永久重定向 表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。使用场景 当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。 302 临时重定向 表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。使用场景 当我们在做活动时，登录到首页自动重定向，进入活动页面。 未登陆的用户访问用户中心重定向到登录页面。 访问404页面重新定向到首页。 304 Not Modified 浏览器缓存相关。 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。 304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。带条件的请求（HTTP 条件请求）：使用 GET方法 请求，请求报文中包含（if-match、if-none-match、if-modified-since、if-unmodified-since、if-range）中任意首部。 304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。 400 Bad Request 表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。 401 Unauthorized 表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败, 比如登录失败 403 Forbidden 表示请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。 404 Not Found 表示服务器上无法找到请求的资源。 405 Method Not Allowed 表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE 500 Internal Server Error 表示服务器端在执行请求时发生了错误。例如出现了 Bug 502 Bad Gateway 表示扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502： 503 Service Unavailable 表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。使用场景： 服务器停机维护时，主动用503响应请求； nginx 设置限速，超过限速，会返回503。 504 Gateway Timeout 表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。使用场景：代码执行时间超时，或者发生了死循环。 浏览器中输入URL按下回车后发生了什么解析URL： 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。会对非法字符进行转义 缓存判断： 如果存在有效的缓存, 就直接使用缓存，否则向服务器发起新的请求。 DNS解析： 此步骤主要是获取IP地址, 具体步骤：本地是否有缓存-&gt;否-&gt;本地 DNS 服务器是否有缓存-&gt;否-&gt;向根域名服务器发起请求-&gt;得到IP地址 获取MAC地址： 获取目标网址的 MAC( 局域网地址) 地址, 主要是需要判断目标地址与当前机器是否在同一个子网, 不在就需要网关转发。TCP三次握手： 建立 TCP 连接。 HTTPS握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。下面看详解 返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。 页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。 TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。 HTTPS通信(握手)过程客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。 HTTP三次握手三次握手（Three-way Handshake）其实就是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。第一次握手： 客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。第二次握手： 服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。第三次握手： 客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。那为什么要三次握手呢？两次不行吗？为了确认双方的接收能力和发送能力都正常如果是用两次握手，则会出现下面这种情况： 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。 TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。 HTTP四次挥手第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。 第二次挥手： 服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。 即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。 第三次挥手： 如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。 第四次挥手： 客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵 以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。 为什么需要四次挥手呢？ 因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。 TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代表不能再向对方发送数据，连接处于的是半释放的状态。最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能正常关闭。","link":"/2021/07/01/20210710HTTP%E7%9A%84%E8%BF%9B%E9%98%B6%E5%92%8C%E7%90%86%E8%A7%A3/"},{"title":"在vue3中pinia页面刷新数据丢失的解决办法","text":"pinia不多介绍。官方文档https://pinia.vuejs.org/introduction.html 1npm install pinia@next 在vue2中 插件 pinia-plugin-persist 可以辅助实现数据持久化功能。https://seb-l.github.io/pinia-plugin-persist/。 1npm i pinia-plugin-persist --save 但是在这个插件只能在vue2中使用，vue3还未适配。。。 只有自己实现一个建议的状态存储了。 使用如下先创建一个简单的状态管理user.js 12345678910111213import { defineStore } from &quot;pinia&quot;;export default defineStore({ id: &quot;user&quot;, state: ()=&gt; ({ mkey:&quot;/home&quot;, data:{} }), actions:{ countPlusOne() { this.count++; }, },}); 创建piniaPluginPersist.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import {user} from &quot;@/store/index.js&quot;var catchList=[ &quot;[object String]&quot;, &quot;[object Number]&quot;, &quot;[object Boolean]&quot;, &quot;[object Array]&quot;, &quot;[object Object]&quot;,]//获取对象集function setPiniaObj(stores=[]){ var itemsObj={} //key模块名称,value模块对象 stores.forEach(item=&gt;{ var key=item.$id var value={} for (let k in item){ if(catchList.includes(Object.prototype.toString.call(item[k]))&amp;&amp;(k!=&quot;$id&quot;)){ value[k]=item[k] } } itemsObj[key]=value }) return itemsObj}export const persistPinia = (window) =&gt;{ //设置缓存 var catchStore = sessionStorage.getItem(&quot;_piniaPluginPersist&quot;) if(catchStore){ catchStore=JSON.parse(catchStore) var storeArr = [user()] storeArr.forEach(item=&gt;{ var data=catchStore[item.$id] for (let k in item){ if(item[k]!==undefined&amp;&amp;(k!=&quot;$id&quot;)){item[k]=data[k]} } }) sessionStorage.removeItem(&quot;_piniaPluginPersist&quot;) } //监听刷新 window.addEventListener(&quot;beforeunload&quot;,()=&gt;{ console.log(&quot;222&quot;) var storeObj=setPiniaObj([user()]) sessionStorage.setItem(&quot;_piniaPluginPersist&quot;,JSON.stringify(storeObj)) })} mainjs全局挂在函数 12import { persistPinia } from &quot;@/utils/piniaPluginPersist.js&quot;app.config.globalProperties.$persistPinia=persistPinia 在App.vue中使用 123import {getCurrentInstance , reactive } from 'vue';const { proxy } = getCurrentInstance();proxy.persistPinia(window); 解决","link":"/2021/09/20/20210920%E5%9C%A8vue3%E4%B8%ADpinia%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"浏览器的文件加密解密","text":"对文件加/解密路线 1file -&gt; buffer -&gt; uint8list -&gt; wordArray(crypto-js辅助类型) -&gt; 加/解密后的wordArray -&gt; uint8list 可以根据业务需求uint8list 转 buffer 或者 blob等 demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *{ font-size: 40px; } button{ display: block; width: 300px; height: 120px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;file&quot; id=&quot;inp&quot; /&gt;&lt;button onclick=&quot;encFn()&quot;&gt;加解密字符串&lt;/button&gt;&lt;button onclick=&quot;decFn()&quot;&gt;加解密文件&lt;/button&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; id=&quot;img&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;crypto-js/crypto-js.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; class CryptoJSTB { iv=null key=null mode= null padding=null static fromJson(opt={}){ var intance = new CryptoJSTB(); let {iv,key,mode,padding} = opt intance.iv=iv; intance.key=key; intance.mode=mode||CryptoJS.mode.CBC; intance.padding=padding||CryptoJS.pad.Pkcs7; return intance } ///加密字符串 encStrAES (plainText) { let options = {iv:this.iv,mode:this.mode,padding:this.padding} let words = CryptoJS.enc.Utf8.parse(plainText) let encrypted = CryptoJS.AES.encrypt(words,this.key,options) return CryptoJS.enc.Base64.stringify(encrypted.ciphertext) } ///解密字符串 decStrAES (plainText) { let options = {iv:this.iv,mode:this.mode,padding:this.padding} ///加密的时候导出的base64，这里也用base64解析 let base64 = CryptoJS.enc.Base64.parse(plainText) let src = CryptoJS.enc.Base64.stringify(base64) let decrypt = CryptoJS.AES.decrypt(src, this.key, options) let decryptedStr = decrypt.toString(CryptoJS.enc.Utf8) return decryptedStr.toString() } ///加密字节 encByteAES(plainText){ var wordArray = this.Uint8ToW(plainText); // Uint8Array-&gt;WordArray let options = {iv:this.iv,mode:this.mode,padding:this.padding} const res = CryptoJS.AES.encrypt(wordArray, this.key,options).ciphertext return this.WToUint8(res) // WordArray-&gt;Uint8Array } ///解密字节 decByteAES(plainText){ var wordArray = this.Uint8ToW(plainText); // Uint8Array-&gt;WordArray let options = {iv:this.iv,mode:this.mode,padding:this.padding} var content = CryptoJS.lib.CipherParams.create({ciphertext:wordArray}) var res = CryptoJS.AES.decrypt(content, this.key,options) return this.WToUint8(res) // WordArray-&gt;Uint8Array } //类型转换 //Uint8Array -&gt; wordArray Uint8ToW(u8) { const len = u8.length; const words= []; for (let i = 0; i &lt; len; i += 1) { words[i &gt;&gt;&gt; 2] |= (u8[i] &amp; 0xff) &lt;&lt; (24 - (i % 4) * 8); } var res = CryptoJS.lib.WordArray.create(words, len); return res; } //wordArray -&gt; Uint8Array WToUint8(wordArray){ const { words } = wordArray; const { sigBytes } = wordArray; const u8 = new Uint8Array(sigBytes); for (let i = 0; i &lt; sigBytes; i += 1) { const byte = (words[i &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (i % 4) * 8)) &amp; 0xff; u8[i] = byte; } return u8; } ///文件转u8 static fileToUint8(file){ return new Promise((resolve,reject)=&gt;{ var reader = new FileReader(); reader.onload = function (e) {resolve(new Uint8Array(e.target.result))} reader.readAsArrayBuffer(file); }) } ///文件保存 static saveFile(uint8List,fileName){ var blob=new Blob([uint8List]); const link = document.createElement('a'); link.href = window.URL.createObjectURL(blob); link.download = fileName; link.click(); window.URL.revokeObjectURL(link.href); }}///实例化var keyStr=&quot;abcdabcdabcdabcd&quot;var content=&quot;123456789aaaa啊我的哇打多阿瓦达&quot;var c=CryptoJSTB.fromJson({ key: CryptoJS.enc.Utf8.parse(keyStr), iv: CryptoJS.enc.Utf8.parse(keyStr),})///字符串加解密测试function encFn(){ var encStr=c.encStrAES(content) console.log(encStr) var decStr=c.decStrAES(encStr) console.log(decStr)}///文件加解密测试，！！！！！！！！！请先选择文件！！！！！！测试用的是图片，方便查看function decFn(){ ///先将文件读取为字节 var file = document.querySelector(&quot;#inp&quot;).files[0] ///加解密测试 CryptoJSTB.fileToUint8(file).then((result) =&gt; { console.log(result) ///加密 var encByte=c.encByteAES(result) console.log(encByte) var decByte=c.decByteAES(encByte) console.log(decByte) showImg(decByte) })}function showImg(u8){ var blob=new Blob([u8]); var src = window.URL.createObjectURL(blob); var img=document.querySelector(&quot;#img&quot;) img.src = src}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2021/10/02/20211024%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"},{"title":"win下WebAssembly环境安装和尝试(Golang)","text":"准备工作 安装 Git。 安装cmake。https://cmake.org/download/ 安装vs。https://visualstudio.microsoft.com/zh-hans/downloads/ Python 2.7.x，在 Linux 和 OS X上，很可能已经装好了。https://www.python.org/downloads/release/python-2716/ 下载Windows x86-64 MSI installer for AMD64/EM64T/x64 python -V安装环境12git clone https://github.com/juj/emsdk.git//如果速度很慢可以直接去git下载代码 安装各种工具12cd ./emsdkemsdk install latest 生成 ~/.emscripten 文件，激活配置1emsdk activate latest 双击emsdk目录下的emsdk_env.bat文件配置环境变量 12345678910这里可能会报错The changes made to environment variables only apply to the currently running shell instance. Use the 'emsdk_env.bat' to re-enter this environment later, or if you'd like to permanently register this environment permanently, rerun this command with the option --permanent.'xftp' 不是内部或.............，也不是可运行的程序...........解决先查看pyhon的是否在全局可用然后在按照上面的运行emsdk_env.bat --permanent 查看是否已经安装完成1emcc -v 查看全局是否可用，如果不能用单独设置环境变量。12345678910# 具体的变量的按照自己的目录来# 单独设置的环境变量，我这里是windows环境EMSDK=D:\\workspace\\emsdk\\emsdkEMSDK_NODE=%EMSDK%\\node\\14.15.5_64bit\\bin\\node.exeEMSDK_PYTHON=%EMSDK%\\python\\3.9.2-1_64bit\\python.exe# PATH中也要添加环境变量%EMSDK%%EMSDK%\\upstream\\emscripten%EMSDK%\\node\\14.15.5_64bit\\bin 编译第一个wasm文件123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;emscripten/emscripten.h&gt;// 一旦WASM模块被加载，main()中的代码就会执行int main(int argc, char ** argv) { printf(&quot;WebAssembly 的环境已经搭好了\\n&quot;);}// 返回1-6之间的一随机数int EMSCRIPTEN_KEEPALIVE roll_dice() { srand ( time(NULL) ); return rand() % 6 + 1;}然后用命令行工具定位到这个文件夹，执行：emcc index.c -s WASM=1 -O3 -o index.js等待片刻之后，你就能够看见生成了两个新文件：index.jsindex.wasm你可以用html引入这个index.js试试（index.wasm必须和index.js在同一路径下）vscode 使用 open with live server WebAssembly 支持不仅限于 C、C++和 Rust。许多开发人员也在努力纳入对其他语言的支持。以下是当前支持的语言列表。 1234567891011C/C++RustAssemblyScript（类似 TypeScript 的语法）C#F#GoKotlinSwiftDPascalZig Golang-webassembly编译及其错误解决 出现”syscall/js”引入报错的时候（Build constraints exclude all the Go files in ‘E:/GoSdk/go1.18.1/src/syscall/js’），如下方式即可解决。详情参考：https://www.jetbrains.com/help/go/webassembly-project.html。 使用 123456789101112package mainimport ( &quot;syscall/js&quot;)func fibFunc(this js.Value, args []js.Value) interface{} { return &quot;我是Golang中的的方法&quot;}func main() { done := make(chan int, 0) js.Global().Set(&quot;fibFunc&quot;, js.FuncOf(fibFunc)) &lt;-done} 运行需要引入特定的js依赖。 wasm_exec.js文件是框架自带的js驱动wasm(golang)的引擎wasm_exec.html是自带的一个测试demo别删了~~~ 12E:\\GoSdk\\go1.18.1\\misc\\wasm\\wasm_exec.jsE:\\GoSdk\\go1.18.1\\misc\\wasm\\wasm_exec.html //一个运行实例 运行demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253目录结构/wasm_exec.js/wasm_exec.html/test.wasm&lt;!doctype html&gt;&lt;!--Copyright 2018 The Go Authors. All rights reserved.Use of this source code is governed by a BSD-stylelicense that can be found in the LICENSE file.--&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Go wasm&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;wasm_exec.js&quot;&gt;&lt;/script&gt; &lt;script&gt; setTimeout(()=&gt;{console.log(fibFunc())},5000) //这里是判断是否允许加载 wasm 文件的 JavaScript API if (!WebAssembly.instantiateStreaming) { // polyfill WebAssembly.instantiateStreaming = async (resp, importObject) =&gt; { const source = await (await resp).arrayBuffer(); return await WebAssembly.instantiate(source, importObject); }; } const go = new Go(); let mod, inst; WebAssembly.instantiateStreaming(fetch(&quot;test.wasm&quot;), go.importObject).then((result) =&gt; { mod = result.module; inst = result.instance; document.getElementById(&quot;runButton&quot;).disabled = false; }).catch((err) =&gt; { console.error(err); }); async function run() { console.clear(); await go.run(inst); inst = await WebAssembly.instantiate(mod, go.importObject); // reset instance //代码是不会走到这里来的因为go main中阻塞了。 } &lt;/script&gt; &lt;button onClick=&quot;run();&quot; id=&quot;runButton&quot; style=&quot;font-size: 100px;&quot;&gt;Run&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;//ConsoleConsole was cleared我是Golang中的的方法","link":"/2021/10/02/20211111win%E4%B8%8BWebAssembly%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%92%8C%E5%B0%9D%E8%AF%95/"},{"title":"Google Face web端登录","text":"Google 一定要使用最新的文档。https://developers.google.com/identity/gsi/web/guides/migration 控制台 https://console.cloud.google.com/apis/dashboard?project=tabbyceshi 应用 https://console.cloud.google.com/apis/credentials?project=tabbyceshi&amp;supportedpurview=project 测试demo 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!-- &lt;meta name=&quot;google-signin-client_id&quot; content=&quot;466619277311-sk2aoc77hg88lm4llvk74cbiq63utk9i.apps.googleusercontent.com&quot;&gt; --&gt; &lt;!-- &lt;script src=&quot;https://accounts.google.com/gsi/client&quot; async defer&gt;&lt;/script&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div class=&quot;g-signin2&quot; data-onsuccess=&quot;onSignIn&quot;&gt;222&lt;/div&gt; --&gt; &lt;script src=&quot;https://accounts.google.com/gsi/client&quot; async defer&gt;&lt;/script&gt; &lt;div id=&quot;g_id_onload&quot; data-login_uri=&quot;http://localhost:5500/google.html&quot; data-auto_prompt=&quot;false&quot; data-client_id=&quot;541694494382-p228lh72cbf9smp0greo8kekhvetkep3.apps.googleusercontent.com&quot; data-callback=&quot;handleCredentialResponse&quot;&gt; &lt;/div&gt; &lt;div class=&quot;g_id_signin&quot; data-type=&quot;standard&quot;&gt;&lt;/div&gt; &lt;script&gt; function handleCredentialResponse(e){ console.log(e) } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 简易使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 class GoogleSDK { static appendHtmlDOM(attrs=[],dom='script'){ return new Promise((resolve,_)=&gt;{ try{ var body = document.getElementsByTagName('body')[0]; var script = document.createElement(dom); attrs.forEach(i=&gt;{script.setAttribute(i.key,i.value)}) body.appendChild(script); script.onload = function () {resolve()} }catch(e){ console.log(e) } }) } static async GetAaccessToken(client_id) { try{ await GoogleSDK.appendHtmlDOM([ {key:&quot;src&quot;,value:&quot;https://accounts.google.com/gsi/client&quot;}, {key:&quot;type&quot;,value:&quot;text/javascript&quot;}, ]) return new Promise((resolve,reject)=&gt;{ var client= google.accounts.oauth2.initTokenClient({ client_id, scope: 'https://www.googleapis.com/auth/calendar.readonly \\ https://www.googleapis.com/auth/contacts.readonly', callback: (tokenResponse) =&gt; {resolve(tokenResponse)}, }); client.requestAccessToken(); }) }catch(e){ console.log(e) } } static revokeToken(access_token) { google.accounts.oauth2.revoke(access_token, () =&gt; { console.log('access token revoked') }); } static async UserLogin(client_id) { try{ console.log(1) await GoogleSDK.appendHtmlDOM([ {key:&quot;src&quot;,value:&quot;https://accounts.google.com/gsi/client&quot;}, {key:&quot;type&quot;,value:&quot;text/javascript&quot;}, ]) /** 千万别放在有v-if的操作里面！！！ window.handleCredentialResponse=function(e){ console.log(e) } //需要写在html里面 &lt;div id=&quot;g_id_onload&quot; data-login_uri=&quot;http://localhost:5500/google.html&quot; data-auto_prompt=&quot;false&quot; data-client_id=&quot;******&quot; data-callback=&quot;handleCredentialResponse&quot;&gt; &lt;/div&gt; //点击即可登录，触发上面的handleCredentialResponse &lt;div class=&quot;g_id_signin&quot; data-type=&quot;standard&quot;&gt;&lt;/div&gt; */ }catch(e){ console.log(e) } }} 相关报错。先尝试清缓存。如果是 vue/react 把 放在模板文件的head里面 1234Uncaught dw不能用127.0.0.1可以切换成http://localhost:********** FaceBook 开发者 https://developers.facebook.com/docs/development/register?locale=zh_CN 应用 https://developers.facebook.com/apps/?show_reminder=true 白名单 https://developers.facebook.com/apps/1531808977238106/gaming-login/settings/demo1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Facebook Login JavaScript Example&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function checkLoginState() { // Called when a person is finished with the Login Button. FB.getLoginStatus(function (response) { // See the onlogin handler console.log(response); }); } window.fbAsyncInit = function () { FB.init({ appId: '**********', cookie: true, // Enable cookies to allow the server to access the session. xfbml: true, // Parse social plugins on this webpage. version: 'v14.0' // Use this Graph API version for this call. }); FB.getLoginStatus(function (response) { // Called after the JS SDK has been initialized. console.log(response); // The current login status of the person. }); };// function testAPI() { // Testing Graph API after login. See statusChangeCallback() for when this call is made.// console.log('Welcome! Fetching your information.... ');// FB.api('/me', function(response) {// console.log('Successful login for: ' + response.name);// document.getElementById('status').innerHTML = 'Thanks for logging in, ' + response.name + '!';// });// } &lt;/script&gt; &lt;!-- The JS SDK Login Button --&gt; &lt;fb:login-button scope=&quot;public_profile,email&quot; onlogin=&quot;checkLoginState();&quot;&gt;&lt;/fb:login-button&gt; &lt;div id=&quot;status&quot;&gt;&lt;/div&gt; &lt;!-- Load the JS SDK asynchronously --&gt; &lt;script async defer crossorigin=&quot;anonymous&quot; src=&quot;https://connect.facebook.net/en_US/sdk.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 简易使用1234567891011121314151617181920212223242526272829303132333435363738class FaceBookSDK { static appendJSscript(attrs=[]){ return new Promise((resolve,_)=&gt;{ var body = document.getElementsByTagName('body')[0]; var script = document.createElement('script'); attrs.forEach(i=&gt;{script.setAttribute(i.key,i.value)}) body.appendChild(script); script.onload = function () {resolve()} }) } static async FBLogin(appId) { try{ await FaceBookSDK.appendJSscript([ {key:&quot;src&quot;,value:&quot;https://connect.facebook.net/en_US/sdk.js&quot;}, {key:&quot;type&quot;,value:&quot;text/javascript&quot;}, {key:&quot;crossorigin&quot;,value:&quot;anonymous&quot;}, ]) return new Promise((resolve,reject)=&gt;{ window.fbAsyncInit = function () { FB.init({appId,cookie:true,xfbml:true,version:'v14.0'}); FB.getLoginStatus(function (response) { FB.login(function(a) { resolve(a) }); }); }; }) }catch(e){ console.log(e) } }}function login(){ FaceBookSDK.FBLogin(&quot;*****&quot;).then(e=&gt;{ console.log(e) })}","link":"/2021/12/20/20211220GoogleFaceweb%E7%AB%AF%E7%99%BB%E5%BD%95/"},{"title":"在vue的data中调用computed的属性异常","text":"先看问题 12345678910data(){ return { name:this.nickname //undefined }},computed:{ nickname(){ return &quot;1111&quot; }} 在这里很容易想到是执行顺序的问题，computed中的属性和data中的属性最终都会加载到app这个实例下。 如果data中的实例属性被创建完成的时候，computed中的实例属性还没被创建，很明显，在data中获取到computed中的属性必定是undefined… 解决方法 1234name:function(){ return this.nickname }//使用name() 或者直接在computed中对data中的属性赋值，因为此时data已经初始化。 看似简单实际有很多小伙伴都不知道。","link":"/2022/01/02/20220102%E5%9C%A8vue%E7%9A%84data%E4%B8%AD%E8%B0%83%E7%94%A8computed%E7%9A%84%E5%B1%9E%E6%80%A7%E5%BC%82%E5%B8%B8/"},{"title":"IM聊天页面消息时间的展示(web)","text":"值得一提的是微信会根据手机系统的时间制度（24小时，12小时）展示的不一样的时间 比如同一天 早上的11:30 24小时制 11:30 12小时制 上午 11:30 下面时间为毫秒 数据结构因项目而异 核心代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/** * 对Date的扩展，将 Date 转化为指定格式的String。 * * 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字)。 * * 【示例】： * common.formatDate(new Date(), 'yyyy-MM-dd hh:mm:ss.S') ==&gt; 2006-07-02 08:09:04.423 * common.formatDate(new Date(), 'yyyy-M-d h:m:s.S') ==&gt; 2006-7-2 8:9:4.18 * common.formatDate(new Date(), 'hh:mm:ss.S') ==&gt; 08:09:04.423 * */var _formatDate = function (date, fmt) { var o = { &quot;M+&quot;: date.getMonth() + 1, //月份 &quot;d+&quot;: date.getDate(), //日 &quot;h+&quot;: date.getHours(), //小时 &quot;m+&quot;: date.getMinutes(), //分 &quot;s+&quot;: date.getSeconds(), //秒 &quot;q+&quot;: Math.floor((date.getMonth() + 3) / 3), //季度 &quot;S&quot;: date.getMilliseconds() //毫秒 }; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length))); return fmt;};/** * 仿照微信中的消息时间显示逻辑，将时间戳（单位：毫秒）转换为友好的显示格式. * * 1）7天之内的日期显示逻辑是：今天、昨天(-1d)、前天(-2d)、星期？（只显示总计7天之内的星期数，即&lt;=-4d）； * 2）7天之外（即&gt;7天）的逻辑：直接显示完整日期时间。 * * @param {[long]} timestamp 时间戳（单位：毫秒），形如：1550789954260 * @param {boolean} mustIncludeTime true表示输出的格式里一定会包含“时间:分钟” * ，否则不包含（参考微信，不包含时分的情况，用于首页“消息”中显示时） * */var _getTimeStringAutoShort2 = function (timestamp, mustIncludeTime) { // 当前时间 var currentDate = new Date(); // 目标判断时间 var srcDate = new Date(parseInt(timestamp)); var currentYear = currentDate.getFullYear(); var currentMonth = (currentDate.getMonth() + 1); var currentDateD = currentDate.getDate(); var srcYear = srcDate.getFullYear(); var srcMonth = (srcDate.getMonth() + 1); var srcDateD = srcDate.getDate(); var ret = &quot;&quot;; // 要额外显示的时间分钟 var timeExtraStr = (mustIncludeTime ? &quot; &quot; + _formatDate(srcDate, &quot;hh:mm&quot;) : &quot;&quot;); // 当年 if (currentYear == srcYear) { var currentTimestamp = currentDate.getTime(); var srcTimestamp = timestamp; // 相差时间（单位：毫秒） var deltaTime = (currentTimestamp - srcTimestamp); // 当天（月份和日期一致才是） if (currentMonth == srcMonth &amp;&amp; currentDateD == srcDateD) { ret = _formatDate(srcDate, &quot;hh:mm&quot;); } else { // 当年 &amp;&amp; 当天之外的时间（即昨天及以前的时间） // 昨天（以“现在”的时候为基准-1天） var yesterdayDate = new Date(); yesterdayDate.setDate(yesterdayDate.getDate() - 1); // 前天（以“现在”的时候为基准-2天） var beforeYesterdayDate = new Date(); beforeYesterdayDate.setDate(beforeYesterdayDate.getDate() - 2); // 用目标日期的“月”和“天”跟上方计算出来的“昨天”进行比较，是最为准确的（如果用时间戳差值 // 的形式，是不准确的，比如：现在时刻是2019年02月22日1:00、而srcDate是2019年02月21日23:00， // 这两者间只相差2小时，直接用“deltaTime/(3600 * 1000)” &gt; 24小时来判断是否昨天，就完全是扯蛋的逻辑了） if (srcMonth == (yesterdayDate.getMonth() + 1) &amp;&amp; srcDateD == yesterdayDate.getDate()) ret = &quot;昨天&quot; + timeExtraStr; // -1d // “前天”判断逻辑同上 else if (srcMonth == (beforeYesterdayDate.getMonth() + 1) &amp;&amp; srcDateD == beforeYesterdayDate.getDate()){ ret = &quot;前天&quot; + timeExtraStr; // -2d } else { // 跟当前时间相差的小时数 var deltaHour = (deltaTime / (3600 * 1000)); // 如果小于或等 7*24小时就显示星期几 if (deltaHour &lt;= 7 * 24) { var weekday = new Array(7); weekday[0] = &quot;星期日&quot;; weekday[1] = &quot;星期一&quot;; weekday[2] = &quot;星期二&quot;; weekday[3] = &quot;星期三&quot;; weekday[4] = &quot;星期四&quot;; weekday[5] = &quot;星期五&quot;; weekday[6] = &quot;星期六&quot;; // 取出当前是星期几 var weedayDesc = weekday[srcDate.getDay()]; ret = weedayDesc + timeExtraStr; } else{// 否则直接显示完整日期时间 ret = _formatDate(srcDate, &quot;yyyy年M月d日&quot;) + timeExtraStr; } } } } else { // 往年 ret = _formatDate(srcDate, &quot;yyyy年M月d日&quot;) + timeExtraStr; } return ret;};///聊天页面时间展示的最小差function check2TimeGap(t1, t2) { if (Math.abs(t1 - t2) &gt; 1000 * 60 * 5) return true return false}/** * 向新收到的消息列表时间 * * @msg 新收到的消息 * @curStartTime 最近一条消息的时间 * */function msgListTimeHook(msgList,startTime){ var result=[] msgList.forEach((item, index) =&gt; { if (index === 0) { item.viewTime=_getTimeStringAutoShort2(item.time, true) } else if (check2TimeGap(item.time, mes[index-1].time)) { item.viewTime=_getTimeStringAutoShort2(item.time, true) } result.push(item) }) return result}/** * 向新收到的消息列表时间 * * @msg 新收到的消息 * @curStartTime 最近一条消息的时间 * */function msgAloneTimeHook(msg,curStartTime){ if(!curStartTime){ msg.viewTime=_getTimeStringAutoShort2(item.time, true) }else{ if (check2TimeGap(msg.time,curStartTime)) { msg.viewTime=_getTimeStringAutoShort2(item.time, true) } } return msg} 基本使用如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var mes = [ { m: &quot;我是一条消息12&quot;, time: 1630113816000 }, { m: &quot;我是一条消息11&quot;, time: 1661649816000 }, { m: &quot;我是一条消息10.5&quot;, time: 1664159074000 }, { m: &quot;我是一条消息10&quot;, time: 1664328216000 }, { m: &quot;我是一条消息9&quot;, time: 1664378616000 }, { m: &quot;我是一条消息8&quot;, time: 1664378616000 }, { m: &quot;我是一条消息7&quot;, time: 1664378616000 }, { m: &quot;我是一条消息6&quot;, time: 1664378616000 }, { m: &quot;我是一条消息5&quot;, time: 1664378676000 }, { m: &quot;我是一条消息4&quot;, time: 1664379876000 }, { m: &quot;我是一条消息3&quot;, time: 1664379936000 }, { m: &quot;我是一条消息2&quot;, time: 1664380797000 }, { m: &quot;我是一条消息1&quot;, time: 1664381016000 }, { m: &quot;我是一条消息-1&quot;, time: new Date().valueOf()-125*1000 }, { m: &quot;我是一条消息-2&quot;, time: new Date().valueOf()-65*1000 },]///向消息列表中添加时间mes=msgListTimeHook(mes)console.log(mes)///收到消息时判断是否需要展示时间var curStartTime=mes[mes.length-1].timevar newmsg=msgAloneTimeHook({ m: &quot;我是一条消息-3&quot;, time: new Date().valueOf()},curStartTime)console.log(newmsg)// 用于聊天内容界面时_getTimeStringAutoShort2(1550789954260, true);///用于会话列表“消息”界面时_getTimeStringAutoShort2(1550789954260, false); 结果如下 123456789101112131415161718192021[ { m: '我是一条消息12', time: 1630113816000, viewTime: '2021年8月28日 09:23' }, { m: '我是一条消息11', time: 1661649816000, viewTime: '2022年8月28日 09:23' }, { m: '我是一条消息10.5', time: 1664159074000, viewTime: '星期一 10:24' }, { m: '我是一条消息10', time: 1664328216000, viewTime: '昨天 09:23' }, { m: '我是一条消息9', time: 1664378616000, viewTime: '昨天 23:23' }, { m: '我是一条消息8', time: 1664378616000 }, { m: '我是一条消息7', time: 1664378616000 }, { m: '我是一条消息6', time: 1664378616000 }, { m: '我是一条消息5', time: 1664378676000 }, { m: '我是一条消息4', time: 1664379876000, viewTime: '昨天 23:44' }, { m: '我是一条消息3', time: 1664379936000 }, { m: '我是一条消息2', time: 1664380797000, viewTime: '昨天 23:59' }, { m: '我是一条消息1', time: 1664381016000 }, { m: '我是一条消息-1', time: 1664440902124, viewTime: '16:41' }, { m: '我是一条消息-2', time: 1664440962124 }]{ m: '我是一条消息-3', time: 1664441027131 }...","link":"/2022/04/20/20220420IM%E8%81%8A%E5%A4%A9%E9%A1%B5%E9%9D%A2%E6%B6%88%E6%81%AF%E6%97%B6%E9%97%B4%E7%9A%84%E5%B1%95%E7%A4%BAweb/"},{"title":"IM聊天页面消息时间的展示(Flutter)","text":"值得一提的是微信会根据手机系统的时间制度（24小时，12小时）展示的不一样的时间 比如同一天 早上的11:30 24小时制 11:30 12小时制 上午 11:30 下面时间为毫秒 数据结构因项目而异，请根据自己的项目适当更改 dependencies: {intl: ^0.17.0} 核心代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import 'package:intl/intl.dart';String _formatDate(DateTime date, String fmt) { DateFormat outputFormat = DateFormat(fmt); return outputFormat.format(date);}String _getTimeStringAutoShort2(int timestamp, bool mustIncludeTime) { //当前日期 DateTime currentDate = DateTime.now(); int currentYear = currentDate.year; int currentMonth = currentDate.month; int currentDateD = currentDate.day; //传入的日期 millTime为毫秒级时间戳 DateTime srcDate = DateTime.fromMillisecondsSinceEpoch(timestamp); int srcYear = srcDate.year; int srcMonth = srcDate.month; int srcDateD = srcDate.day; ///结果 String ret = &quot;&quot;; String timeExtraStr = mustIncludeTime ? &quot; &quot; + _formatDate(srcDate, &quot;HH:mm&quot;) : &quot;&quot;; if (srcYear == currentYear) { ///当年 int currentTimestamp = currentDate.millisecondsSinceEpoch; int srcTimestamp = timestamp; // 相差时间（单位：毫秒） int deltaTime = (currentTimestamp - srcTimestamp); // 当天（月份和日期一致才是） if (currentMonth == srcMonth &amp;&amp; currentDateD == srcDateD) { ret = _formatDate(srcDate, &quot;HH:mm&quot;); } else { // 当年 &amp;&amp; 当天之外的时间（即昨天及以前的时间） // 昨天（以“现在”的时候为基准-1天） DateTime yesterdayDate = DateTime.fromMillisecondsSinceEpoch(currentTimestamp - 86400000 * 1); // 前天（以“现在”的时候为基准-2天） DateTime beforeYesterdayDate = DateTime.fromMillisecondsSinceEpoch(currentTimestamp - 86400000 * 2); // 用目标日期的“月”和“天”跟上方计算出来的“昨天”进行比较，是最为准确的（如果用时间戳差值 // 的形式，是不准确的，比如：现在时刻是2019年02月22日1:00、而srcDate是2019年02月21日23:00， // 这两者间只相差2小时，直接用“deltaTime/(3600 * 1000)” &gt; 24小时来判断是否昨天，就完全是扯蛋的逻辑了） if (srcMonth == (yesterdayDate.month) &amp;&amp; srcDateD == yesterdayDate.day) { ret = &quot;昨天&quot; + timeExtraStr; // -1d } else if (srcMonth == (beforeYesterdayDate.month) &amp;&amp; srcDateD == beforeYesterdayDate.day) { // “前天”判断逻辑同上 ret = &quot;前天&quot; + timeExtraStr; // -2d } else { // 跟当前时间相差的小时数 var deltaHour = (deltaTime / (3600 * 1000)); // 如果小于或等 7*24小时就显示星期几 if (deltaHour &lt;= 7 * 24) { List&lt;String&gt; weekday = []; weekday.addAll([&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期日&quot;]); // 取出当前是星期几 var weedayDesc = weekday[srcDate.weekday - 1]; ret = weedayDesc + timeExtraStr; } else { // 否则直接显示完整日期时间 ret = _formatDate(srcDate, &quot;yyyy年M月d日&quot;) + timeExtraStr; } } } } else { ///往年 ret = _formatDate(srcDate, &quot;yyyy年M月d日&quot;) + timeExtraStr; } return ret;}///聊天页面时间展示的最小差bool check2TimeGap(int t1, int t2) { if ((t1 - t2).abs() &gt; 1000 * 60 * 5) return true; return false;}/** * 向新收到的消息列表时间 * [msg] 新收到的消息 * [curStartTime] 最近一条消息的时间 */List msgListTimeHook(List msgList) { List result = []; for (var i = 0; i &lt; msgList.length; i++) { var item = msgList[i]; if (i == 0) { item[&quot;viewTime&quot;] = _getTimeStringAutoShort2(item[&quot;time&quot;], true); } else if (check2TimeGap(item[&quot;time&quot;], msgList[i - 1][&quot;time&quot;])) { item[&quot;viewTime&quot;] = _getTimeStringAutoShort2(item[&quot;time&quot;], true); } result.add(item); } return result;}/** * 向新收到的消息列表时间 * * @msg 新收到的消息 * @curStartTime 最近一条消息的时间 * */msgAloneTimeHook(msg, curStartTime) { // if(!curStartTime){ // msg.viewTime=_getTimeStringAutoShort2(item.time, true) // }else{ // if (check2TimeGap(msg.time,curStartTime)) { // msg.viewTime=_getTimeStringAutoShort2(item.time, true) // } // } // return msg} 基本使用如下 1234567891011121314151617181920212223242526272829void main(List&lt;String&gt; args) { var mes = [ {&quot;m&quot;: &quot;我是一条消息12&quot;, &quot;time&quot;: 1630113816000}, {&quot;m&quot;: &quot;我是一条消息11&quot;, &quot;time&quot;: 1661649816000}, {&quot;m&quot;: &quot;我是一条消息11&quot;, &quot;time&quot;: 1664090674000}, {&quot;m&quot;: &quot;我是一条消息周一&quot;, &quot;time&quot;: 1664177074000}, {&quot;m&quot;: &quot;我是一条消息前天&quot;, &quot;time&quot;: 1664263474000}, {&quot;m&quot;: &quot;我是一条消息昨天&quot;, &quot;time&quot;: 1664349874000}, {&quot;m&quot;: &quot;我是一条消息昨天&quot;, &quot;time&quot;: 1664349874000}, {&quot;m&quot;: &quot;我是一条消息昨天&quot;, &quot;time&quot;: 1664349874000}, {&quot;m&quot;: &quot;我是一条消息昨天&quot;, &quot;time&quot;: 1664349874000}, {&quot;m&quot;: &quot;我是一条消息昨天&quot;, &quot;time&quot;: 1664349874000}, {&quot;m&quot;: &quot;我是一条消息1&quot;, &quot;time&quot;: 1664381016000}, ]; // _getTimeStringAutoShort2(1664380797000, true); var a = msgListTimeHook(mes); print(a); // 用于聊天内容界面时 var b = _getTimeStringAutoShort2(1550789954260, true); ///用于会话列表“消息”界面时 var c = _getTimeStringAutoShort2(1550789954260, false); print(a); print(b); print(c); // mes.forEach((i) { // _getTimeStringAutoShort2(i[&quot;time&quot;] as int, true); // });} 大概结果如下下面返回的结果并非使用上面的数据 123456789101112131415161718192021[ { m: '我是一条消息12', time: 1630113816000, viewTime: '2021年8月28日 09:23' }, { m: '我是一条消息11', time: 1661649816000, viewTime: '2022年8月28日 09:23' }, { m: '我是一条消息10.5', time: 1664159074000, viewTime: '星期一 10:24' }, { m: '我是一条消息10', time: 1664328216000, viewTime: '昨天 09:23' }, { m: '我是一条消息9', time: 1664378616000, viewTime: '昨天 23:23' }, { m: '我是一条消息8', time: 1664378616000 }, { m: '我是一条消息7', time: 1664378616000 }, { m: '我是一条消息6', time: 1664378616000 }, { m: '我是一条消息5', time: 1664378676000 }, { m: '我是一条消息4', time: 1664379876000, viewTime: '昨天 23:44' }, { m: '我是一条消息3', time: 1664379936000 }, { m: '我是一条消息2', time: 1664380797000, viewTime: '昨天 23:59' }, { m: '我是一条消息1', time: 1664381016000 }, { m: '我是一条消息-1', time: 1664440902124, viewTime: '16:41' }, { m: '我是一条消息-2', time: 1664440962124 }]{ m: '我是一条消息-3', time: 1664441027131 }...","link":"/2022/04/25/20220425IM%E8%81%8A%E5%A4%A9%E9%A1%B5%E9%9D%A2%E6%B6%88%E6%81%AF%E6%97%B6%E9%97%B4%E7%9A%84%E5%B1%95%E7%A4%BAFlutter/"},{"title":"IM项目中electron对文件加密的方案设计与落地","text":"文本加密很好实现，但是文件加密就稍微麻烦点。 但是我的预期加密的规则需要兼容老版本能够分辨出老版本未加密的文件，因为我们用户还可能查看老版本的聊天记录。能够分别不同版本规则的加密文件。文件不能全加密，效率要高。加密过后的文件大小，不能太大，要节约oss资源控制成本，这里我改成了一个参，可以手动设置加密后的文件新增的大小。视情况而定。 最终的加密路线如下： 核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248class TBFileRules { static checkHeadSign=[&quot;abcdabcdabcdabc&quot;,&quot;abcdabcdabcdabcd&quot;] ///解密时使用。是否符合解密文件。 static headSign={sign:&quot;abcdabcdabcdabcd&quot;,headLen:1024/2} ///加密时使用。标记为加密文件。对象编译过后的字节长度不能超过50 static appKey=&quot;tabby&quot; ///appkey static encDataLen=1024*10; ///加密的长度，文件小于这个长度全加密 默认只加密10kb /** @param {string} -sgin:app签名 @param {Number} -headLen:文件头的总长度 @param {Number} -fileLen:文件的原长 @param {Number} -fileEncLen:文件加密后总体的长度（不含头） @param {Number} -fileDataLen:加密段加密前的长度 @param {Number} -fileDataEncLen:加密段加密后的长度 @param {Number} -fileEncStart:加密后加密段开始的位置（不含头） @param {string} -ext:预留拓展字段 */ static generateHeaderByte(opt={}){ var {fileLen,fileEncLen,fileDataLen,fileDataEncLen,fileEncStart,ext}=opt; let header={} header.sgin=TBFileRules.appKey; ///32 位app签名 header.headLenSign=50; ///加密标识的长度 header.headLen=TBFileRules.headSign.headLen; ///文件头的总长度 header.fileLen=fileLen; ///文件的原长 header.fileEncLen=fileEncLen; ///文件加密后总体的长度（不含头） header.fileDataLen=fileDataLen; ///加密段加密前的长度 header.fileDataEncLen=fileDataEncLen; ///加密段加密后的长度 header.fileEncStart=fileEncStart; ///加密后加密段开始的位置（不含头） header.ext=ext; ///预留拓展字段 // console.log(header) return TBFileRules.strToByte(JSON.stringify(header)) } /** 检查是否为加密文件 @param {Uint8Array} -source:源文件 */ static checkIsEncFile(source){ try{ var headSign=JSON.parse(TBFileRules.byteToStr(TBFileRules.unshif0(source.slice(0,50)))) if(TBFileRules.checkHeadSign.indexOf(headSign.sign)&gt;-1)return headSign return false }catch(e){ console.log(e) return false } } /** 加密文件 @param {CryptoJSTB} -cjstb:CryptoJSTB 实例 @param {Uint8Array} -source:源文件 @param {String} -ext:拓展 */ static encData(opt={}){ return new Promise((resolve,reject)=&gt;{ var {cjstb,source,ext}=opt source=Array.from(source) if(!ext)ext=&quot;&quot; var encDataU8=[], //加密前的加密段 fileEnd=TBFileRules.encDataLen, //加密结束的位置 encDataSourceU8=[], //加密后的加密段 sourceOtherData=[], //未加密的部分 sourceEecData=[]; //未加密的部分 if(fileEnd&gt;source.length)fileEnd=source.length else sourceOtherData=source.slice(fileEnd) encDataU8=source.slice(0,fileEnd) encDataSourceU8=cjstb.encByteAES(encDataU8) sourceEecData=[...encDataSourceU8,...sourceOtherData] var headerParams = TBFileRules.generateHeaderByte({ fileLen:source.length, fileEncLen:sourceEecData.length, fileDataLen:encDataU8.length, fileDataEncLen:encDataSourceU8.length, ext }) var headerSign = TBFileRules.strToByte(JSON.stringify(TBFileRules.headSign)) if(headerSign.length&lt;=50){ let ent=[] for(let i=0;i&lt;50-headerSign.length;i++){ent.push(0)} headerSign=[...headerSign,...ent] }else{ reject({code:0,msg:&quot;headerSign.length too long 50&quot;}) } var head=[...headerSign,...headerParams] if(head.length&lt;TBFileRules.headSign.headLen){ let ent=[] for(let i=0;i&lt;TBFileRules.headSign.headLen-head.length;i++){ent.push(0)} head=[...head,...ent] }else{ reject({code:0,msg:&quot;File head too long&quot;}) } resolve({code:1,data:new Uint8Array([...head,...sourceEecData])}) }) } /** 解密密文件 @param {CryptoJSTB} -cjstb:CryptoJSTB 实例 @param {Uint8Array} -source:源文件 */ static decData(opt={}){ return new Promise((resolve,reject)=&gt;{ var {source,cjstb}=opt source=Array.from(source) var headSign=TBFileRules.checkIsEncFile(source) if(!headSign){ reject({code:0,msg:&quot;Failed to parse file&quot;}) return } var headParamsByte = source.slice(50,headSign.headLen) var headParamsByteUnfit0 = TBFileRules.unshif0(headParamsByte) var headParams = JSON.parse(TBFileRules.byteToStr(headParamsByteUnfit0)) var encData=source.slice(headSign.headLen,headSign.headLen + headParams.fileDataEncLen) var otherData=source.slice(headSign.headLen + headParams.fileDataEncLen) var decData=cjstb.decByteAES(encData) resolve({ code:1, params:headParams, data:new Uint8Array([...decData,...otherData]) }) }) } /** 文件转u8 @param {file} @return {Promise&lt;Uint8Array&gt;} */ static fileToUint8(file){ return new Promise((resolve,reject)=&gt;{ var reader = new FileReader(); reader.onload = function (e) {resolve(new Uint8Array(e.target.result))} reader.readAsArrayBuffer(file); }) } static saveFile(uint8List,fileName){ var blob=new Blob([uint8List]); const link = document.createElement('a'); link.href = window.URL.createObjectURL(blob); link.download = fileName; link.click(); window.URL.revokeObjectURL(link.href); } ///去除字节最后的0 static unshif0(list){ var data=[...list] for(let i=0;i&lt;list.length;i++){ if(data[data.length-1])return data else data.pop() } } static strToByte(str) { var bytes = new Array(); var len, c; len = str.length; for (var i = 0; i &lt; len; i++) { c = str.charCodeAt(i); if (c &gt;= 0x010000 &amp;&amp; c &lt;= 0x10FFFF) { bytes.push(((c &gt;&gt; 18) &amp; 0x07) | 0xF0); bytes.push(((c &gt;&gt; 12) &amp; 0x3F) | 0x80); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); } else if (c &gt;= 0x000800 &amp;&amp; c &lt;= 0x00FFFF) { bytes.push(((c &gt;&gt; 12) &amp; 0x0F) | 0xE0); bytes.push(((c &gt;&gt; 6) &amp; 0x3F) | 0x80); bytes.push((c &amp; 0x3F) | 0x80); } else if (c &gt;= 0x000080 &amp;&amp; c &lt;= 0x0007FF) { bytes.push(((c &gt;&gt; 6) &amp; 0x1F) | 0xC0); bytes.push((c &amp; 0x3F) | 0x80); } else { bytes.push(c &amp; 0xFF); } } return bytes; } static byteToStr(utf8Bytes){ var unicodeStr =&quot;&quot;; for (var pos = 0; pos &lt; utf8Bytes.length;){ var flag= utf8Bytes[pos]; var unicode = 0 ; if ((flag &gt;&gt;&gt;7) === 0 ) { unicodeStr+= String.fromCharCode(utf8Bytes[pos]); pos += 1; } else if ((flag &amp;0xFC) === 0xFC ){ unicode = (utf8Bytes[pos] &amp; 0x3) &lt;&lt; 30; unicode |= (utf8Bytes[pos+1] &amp; 0x3F) &lt;&lt; 24; unicode |= (utf8Bytes[pos+2] &amp; 0x3F) &lt;&lt; 18; unicode |= (utf8Bytes[pos+3] &amp; 0x3F) &lt;&lt; 12; unicode |= (utf8Bytes[pos+4] &amp; 0x3F) &lt;&lt; 6; unicode |= (utf8Bytes[pos+5] &amp; 0x3F); unicodeStr+= String.fromCharCode(unicode) ; pos += 6; }else if ((flag &amp;0xF8) === 0xF8 ){ unicode = (utf8Bytes[pos] &amp; 0x7) &lt;&lt; 24; unicode |= (utf8Bytes[pos+1] &amp; 0x3F) &lt;&lt; 18; unicode |= (utf8Bytes[pos+2] &amp; 0x3F) &lt;&lt; 12; unicode |= (utf8Bytes[pos+3] &amp; 0x3F) &lt;&lt; 6; unicode |= (utf8Bytes[pos+4] &amp; 0x3F); unicodeStr+= String.fromCharCode(unicode) ; pos += 5; } else if ((flag &amp;0xF0) === 0xF0 ){ unicode = (utf8Bytes[pos] &amp; 0xF) &lt;&lt; 18; unicode |= (utf8Bytes[pos+1] &amp; 0x3F) &lt;&lt; 12; unicode |= (utf8Bytes[pos+2] &amp; 0x3F) &lt;&lt; 6; unicode |= (utf8Bytes[pos+3] &amp; 0x3F); unicodeStr+= String.fromCharCode(unicode) ; pos += 4; } else if ((flag &amp;0xE0) === 0xE0 ){ unicode = (utf8Bytes[pos] &amp; 0x1F) &lt;&lt; 12;; unicode |= (utf8Bytes[pos+1] &amp; 0x3F) &lt;&lt; 6; unicode |= (utf8Bytes[pos+2] &amp; 0x3F); unicodeStr+= String.fromCharCode(unicode) ; pos += 3; } else if ((flag &amp;0xC0) === 0xC0 ){ //110 unicode = (utf8Bytes[pos] &amp; 0x3F) &lt;&lt; 6; unicode |= (utf8Bytes[pos+1] &amp; 0x3F); unicodeStr+= String.fromCharCode(unicode) ; pos += 2; } else{ unicodeStr+= String.fromCharCode(utf8Bytes[pos]); pos += 1; } } return unicodeStr; }} 测试demo https://github.com/TabbyCute/web_libs/tree/main/demos/crypto-js-bigfile 项目使用 https://github.com/TabbyCute/web_libs/tree/main/libs/crypto-js-bigfile","link":"/2022/05/08/20220508IM%E9%A1%B9%E7%9B%AE%E4%B8%ADelectron%E5%AF%B9%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E7%9A%84%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%90%BD%E5%9C%B0/"},{"title":"查看yum软件的安装目录","text":"今天使用yum 安装了一个软件，后来没有找到路径 1、首先安装一个redis 1[root@iZbp1eem925ojwyx17ao9kZ ~]# yum install redis 2、查找redis的安装包 123[root@iZbp1eem925ojwyx17ao9kZ ~]# rpm -qa|grep redisredis-3.2.10-2.el7.x86_64[root@iZbp1eem925ojwyx17ao9kZ ~]# 3、查找安装包的安装路径 123456789101112[root@iZbp1eem925ojwyx17ao9kZ ~]# rpm -ql redis-3.2.10-2.el7.x86_64/etc/logrotate.d/redis/etc/redis-sentinel.conf/etc/redis.conf/etc/systemd/system/redis-sentinel.service.d/etc/systemd/system/redis-sentinel.service.d/limit.conf/etc/systemd/system/redis.service.d/etc/systemd/system/redis.service.d/limit.conf/usr/bin/redis-benchmark/usr/bin/redis-check-aof/usr/bin/redis-check-rdb/usr/bin/redis-cli","link":"/2022/05/01/20220601%E6%9F%A5%E7%9C%8Byum%E5%AE%89%E8%A3%85%E7%9A%84%E8%BD%AF%E4%BB%B6%E4%BD%8D%E7%BD%AE/"},{"title":"Mac M1 flutter环境从装机到真机保姆级教程","text":"flutter环境的安装安装Android Studio这个没什么好说的傻瓜式安装，需要注意的是Mac的可能会选择多个版本，M1一定要选arm架构的，这个很重要。 确保能运行一个空白的项目起来。 安装Flutter下载flutterSDK。M1一定要选择arm64的版本sdk！！！ (https://docs.flutter.dev/development/tools/sdk/releases?tab=macos#macos) 解压到某个目录，我这里解压的目录是 /Users/bz/FlutterSDK 导出环境变量 1234export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn// 上面两个为国内镜像，下面为sdk的环境变量export PATH=/Users/bz/FlutterSDK/bin:$PATH 解决重启电脑命令失效完成了上面的步骤，现在在命令行运行flutter doctor应该是可以的。但是有个问题，当你重启电脑再次到命令行里面运行flutter doctor会提示命令不存在。 向 ~/.bash_profile文件中添加（如果不存在就先创建） 下面的 export PATH=/Users/bz/FlutterSDK/bin:$PATH 取决于你上面安装sdk的位置 12345sudo vi ~/.bash_profile//添加如下export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cnexport PATH=/Users/bz/FlutterSDK/bin:$PATH 刷新此文件1source ~/.bash_profile 执行flutter doctor。 现在是每次开机都需要执行source ~/.bash_profile才能正常使用bash_profile里的命令 在~/.zshrc（如果没有就添加）添加 source ~/.bash_profile123vim ~/.zshrc//添加如下source ~/.bash_profile 安装homebrew下载homebrew仓库12sudo mkdir /opt/Homebrewsudo git clone https://mirrors.ustc.edu.cn/brew.git /opt/Homebrew 下载homebrew-core仓库12sudo mkdir -p /opt/Homebrew/Library/Taps/homebrew/homebrew-coresudo git clone https://mirrors.ustc.edu.cn/homebrew-core.git /opt/Homebrew/Library/Taps/homebrew/homebrew-core 只将可执行文件放在PATH搜索路径中123sudo mkdir /opt/binecho export PATH=$PATH:/opt/binsudo ln -s /opt/Homebrew/bin/brew /opt/bin/brew var目录下存放锁1234sudo mkdir -p /opt/var/Homebrew//该目录存放可能的配置文件，无则创建sudo mkdir /opt/etc 改变目录权限12sudo chown -R $(whoami) /opt/Homebrewsudo chown -R $(whoami) /opt/etc 验证是否安装成功1brew update 如果提示命令不存在，就在~/.bash_profile中添加，完了记得。source ~/.bash_profile 1export PATH=/opt/Homebrew/bin:$PATH 此路径取决于你安装的位置。/opt/Homebrew/bin目录下有个brew可执行文件，可以先执行./brew v 检查是否有问题，添加好了过后就执行 安装cocoapods12345brew install cocoapodsgit clone https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git ~/.cocoapods/repos/master 进入flutter项目的ios中 1pod install 中途拉库的时候可能会失败，然后重复拉有可能会报错提示pod repo update，直接执行pod repo update就ok老项目记得删除 Podfile.lock .","link":"/2021/10/02/20220625M1%E6%90%AD%E5%BB%BAflutter%E7%8E%AF%E5%A2%83/"},{"title":"查看yum软件的安装目录","text":"官网推荐安装 卸载旧版本12345678910111213yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine#卸载 Docker Engine、CLI、Containerd 和 Docker Compose 软件包：yum remove docker-ce docker-ce-cli containerd.io docker-compose-plugin#主机上的映像、容器、卷或自定义配置文件不会自动删除。要删除所有映像、容器和卷：sudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd 开始安装 设置存储库。安装yum-utils包（提供yum-config-manager 实用程序）并设置存储库。 1234567891011sudo yum install -y yum-utilssudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo#可以使用阿里源，最好选这个yum-config-manager --add-repo=http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum makecache #重新构建缓存yum repolist {all|enabled|disabled} #列出所有/已启用/已禁用的yum源yum --disablerepo=repo #临时禁用某个repo源yum --enablerepo=repo #解除禁用某个repo源 安装 Docker 引擎。安装最新版本的 Docker Engine、containerd 和 Docker Compose 1sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 要安装特定版本的 Docker Engine，请在 repo 中列出可用版本，然后选择并安装 1234567yum list docker-ce --showduplicates | sort -rdocker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stable docker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stable docker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable 安装。具体的版本可以选择 1234#默认安装sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin#可以选择版本sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin 结束 1234sudo systemctl start docker #启动sudo systemctl enable docker #开机启动docker version #查看版本docker run hello-world #示例进项 如果超时了切换一下yum源yum-config-manager –add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 官网脚本安装 12345curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh或者sudo DRY_RUN=1 sh ./get-docker.sh 安装gcc 12yum -y install gccyum -y install gcc c++ 镜像加速 创建 /etc/docker 加入地址 12345678910sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot;: [ &quot;https://mirror.ccs.tencentyun.com&quot; ]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker","link":"/2022/06/10/20220610docker%E7%9A%84%E5%AE%89%E8%A3%85/"},{"title":"etcd单节点安装和golang的简单使用","text":"安装golang1yum install golang etcd单节点安装源码包安装下载etcd1wget https://github.com/etcd-io/etcd/releases/download/v3.1.5/etcd-v3.1.5-linux-amd64.tar.gz 解压 etcd-v3.1.5-linux-amd64.tar.gz 压缩文件1tar -zxf etcd-v3.1.5-linux-amd64.tar.gz 将文件夹中etcd和etcdctl两个文件添加可执行文件路径到环境变量PATH中。1234//进入文件夹cd etcd-v3.1.5-linux-amd64///将文件夹中etcd和etcdctl两个文件添加可执行文件路径到环境变量PATH中。mv etcd* /usr/local/bin 修改使用的api等级12export ETCDCTL_API=3source /etc/profile 查看版本信息1234567891011etcdctl vetcdctl version: 3.1.5API version: 3.1etcd --versionetcd Version: 3.1.5Git SHA: 2cf9e51Go Version: go1.10.3Go OS/Arch: linux/amd64 创建etcd数据存放位置12// 数据存放位置的文件夹mkdir -p /var/lib/etcd/ 创建启动文件12345678910111213141516171819202122cat &lt;&lt;EOF | sudo tee /etc/systemd/system/etcd.service//复制以下即可[Unit]Description=Etcd ServerDocumentation=https://github.com/coreos/etcdAfter=network.target [Service]User=rootType=notifyEnvironment=ETCD_NAME=etcd_test_1Environment=ETCD_DATA_DIR=/var/lib/etcd/ExecStart=/usr/local/bin/etcdRestart=on-failureRestartSec=10sLimitNOFILE=40000 [Install]WantedBy=multi-user.targetEOF 重新加载配置 &amp;&amp; 开机启动 &amp;&amp; 启动 etcd启动etcd123systemctl daemon-reload &amp;&amp; systemctl enable etcd &amp;&amp; systemctl start etcd//成功如下Created symlink from /etc/systemd/system/multi-user.target.wants/etcd.service to /etc/systemd/system/etcd.service. 开机启动设置状态，状态 enabled1234567systemctl list-unit-files etcd.service//成功如下UNIT FILE STATE etcd.service enabled 1 unit files listed. 查看 etcd 状态1systemctl show etcd.service 测试12345etcdctl put mykey &quot;this is etcd2&quot;OKetcdctl get mykeymykeythis is etcd 外网连接当然，etcd默认本地访问。如果需要远程访问需要在配置文件（/etc/etcd.conf 上面创建的文件）中加上如下操作。注意如果上面一行不是字符串需要加个 1234567891011121314[Service]User=rootType=notifyEnvironment=ETCD_NAME=etcd_test_1Environment=ETCD_DATA_DIR=/var/lib/etcd/Environment=ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379Environment=ETCD_ADVERTISE_CLIENT_URLS=http://0.0.0.0:2379或者直接使用本机Environment=ETCD_LISTEN_CLIENT_URLS=http://1.117.72.92:2379Environment=ETCD_ADVERTISE_CLIENT_URLS=http://1.117.72.92:2379ExecStart=/usr/local/bin/etcd 如果当前已经启动了修改的配置 12345# 重启生效systemctl restart etcd# 重启生效systemctl stop etcdsystemctl daemon-reload &amp;&amp; systemctl enable etcd &amp;&amp; systemctl start etcd 常用配置 –name：方便理解的节点名称，默认为 default，在集群中应该保持唯一，可以使用 hostname –data-dir：服务运行数据保存的路径，默认为 ${name}.etcd –snapshot-count：指定有多少事务（transaction）被提交时，触发截取快照保存到磁盘 –heartbeat-interval：leader 多久发送一次心跳到 followers。默认值是 100ms –eletion-timeout：重新投票的超时时间，如果follower在该时间间隔没有收到心跳包，会触发重新投票，默认为 1000 ms –listen-peer-urls：和同伴通信的地址，比如 http://ip:2380，如果有多个，使用逗号分隔。需要所有节点都能够访问，所以不要使用 localhost –listen-client-urls：对外提供服务的地址：比如 http://ip:2379,http://127.0.0.1:2379，客户端会连接到这里和etcd交互 –advertise-client-urls：对外公告的该节点客户端监听地址，这个值会告诉集群中其他节点 –initial-advertise-peer-urls：该节点同伴监听地址，这个值会告诉集群中其他节点 –initial-cluster：集群中所有节点的信息，格式为 node1=http://ip1:2380,node2=http://ip2:2380,…。需要注意的是，这里的 node1 是节点的–name指定的名字；后面的ip1:2380 是–initial-advertise-peer-urls 指定的值 –initial-cluster-state：新建集群的时候，这个值为 new；假如已经存在的集群，这个值为existing –initial-cluster-token：创建集群的token，这个值每个集群保持唯一。这样的话，如果你要重新创建集群，即使配置和之前一样，也会再次生成新的集群和节点 uuid；否则会导致多个集群之间的冲突，造成未知的错误 这些选项，与上面我们配置文件里的配置一一对应，如ETCD_INITIAL_CLUSTER等同于–inital-cluster, ETCD_INITIAL_CLUSTER_STATE等同于–initial-cluster-state。 所有以–init开头的配置都是在第一次启动etcd集群的时候才会用到，后续节点的重启会被忽略，如–initial-cluseter参数。所以当成功初始化了一个etcd集群以后，就不再需要这个参数或环境变量了。 常用命令12345systemctl daemon-reloadsystemctl enable etcdsystemctl start etcdsystemctl stop etcdetcdctl member list //查看节点 报错收集123No help topic for ‘put’export ETCDCTL_API=3 解决 etcd git官方安装脚本 https://github.com/etcd-io/etcd/releases继续从 &lt;&lt;将文件夹中etcd和etcdctl两个文件添加可执行文件路径到环境变量PATH中&gt;&gt; 开始 etcd yum安装123yum install etcd//继续从 &lt;&lt;修改使用的api等级&gt;&gt; 开始 安装etcd webui 记得启动Etcd服务。 先安装node，git环境，然后clone。 安装node可以到 http://nodejs.cn/download/下载对应的 node 版本。123git clone https://github.com/henszey/etcd-browser.gitcd etcd-browser/vim server.js 编辑server.js，修改内容如下：123var etcdHost = process.env.ETCD_HOST || '127.0.0.1'; # etcd 主机IPvar etcdPort = process.env.ETCD_PORT || 2379; # etcd 主机端口var serverPort = process.env.SERVER_PORT || 8000; # etcd-browser 监听端口 然后启动1node server.js 访问：http://127.0.0.1:8000/ go连接etcd和一些操作put/get的简单操作示例1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;go.etcd.io/etcd/client/v3&quot; &quot;time&quot;)func main() { cli, err := clientv3.New(clientv3.Config{ Endpoints: []string{&quot;127.0.0.1:2379&quot;}, DialTimeout: 5 * time.Second, }) if err != nil { // handle error! fmt.Printf(&quot;connect to etcd failed, err:%v\\n&quot;, err) return } fmt.Println(&quot;connect to etcd success&quot;) defer cli.Close() // put ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) _, err = cli.Put(ctx, &quot;k1&quot;, &quot;v1&quot;) cancel() if err != nil { fmt.Printf(&quot;put to etcd failed, err:%v\\n&quot;, err) return } // get ctx, cancel = context.WithTimeout(context.Background(), 3*time.Second) resp, err := cli.Get(ctx, &quot;k1&quot;) cancel() if err != nil { fmt.Printf(&quot;get from etcd failed, err:%v\\n&quot;, err) return } for _, ev := range resp.Kvs { fmt.Printf(&quot;%s:%s\\n&quot;, ev.Key, ev.Value) }} watch的使用12345678910111213141516171819202122232425262728package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;go.etcd.io/etcd/client/v3&quot; &quot;time&quot;)func main() { cli, err := clientv3.New(clientv3.Config{ Endpoints: []string{&quot;127.0.0.1:2379&quot;}, DialTimeout: 5 * time.Second, }) if err != nil { fmt.Printf(&quot;connect to etcd failed, err:%v\\n&quot;, err) return } fmt.Println(&quot;connect to etcd success&quot;) defer cli.Close() // watch key:q1mi change rch := cli.Watch(context.Background(), &quot;k1&quot;) // &lt;-chan WatchResponse for wresp := range rch { for _, ev := range wresp.Events { fmt.Printf(&quot;Type: %s Key:%s Value:%s\\n&quot;, ev.Type, ev.Kv.Key, ev.Kv.Value) } }} 在同级的目录下cmd进入(下面操作是在windows上进行的，因为方便) 123etcdctl.exe --endpoints=http://127.0.0.1:2379 put k1 &quot;xixixixix&quot;etcdctl.exe --endpoints=http://127.0.0.1:2379 del k1etcdctl.exe --endpoints=http://127.0.0.1:2379 put k1 &quot;dsb3&quot; lease租约的使用123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;go.etcd.io/etcd/client/v3&quot; &quot;time&quot;)func main() { cli, err := clientv3.New(clientv3.Config{ Endpoints: []string{&quot;127.0.0.1:2379&quot;}, DialTimeout: time.Second * 5, }) if err != nil { fmt.Println(err) } fmt.Println(&quot;connect to etcd success.&quot;) defer cli.Close() // 创建一个5秒的租约 resp, err := cli.Grant(context.TODO(), 5) if err != nil { fmt.Println(err) } fmt.Println(resp.ID) // 5秒钟之后, /aaaa/ 这个key就会被移除 _, err = cli.Put(context.TODO(), &quot;/aaaa/&quot;, &quot;dsb&quot;, clientv3.WithLease(resp.ID)) if err != nil { fmt.Println(err) } time.Sleep(time.Second * 6)} keepAlive12345678910111213141516171819202122232425262728293031func main() { cli, err := clientv3.New(clientv3.Config{ Endpoints: []string{&quot;127.0.0.1:2379&quot;}, DialTimeout: time.Second * 5, }) if err != nil { fmt.Println(err) } fmt.Println(&quot;connect to etcd success.&quot;) defer cli.Close() resp, err := cli.Grant(context.TODO(), 5) if err != nil { fmt.Println(err) } _, err = cli.Put(context.TODO(), &quot;/aaaa/&quot;, &quot;dsb&quot;, clientv3.WithLease(resp.ID)) if err != nil { fmt.Println(err) } // the key 'foo' will be kept forever ch, kaerr := cli.KeepAlive(context.TODO(), resp.ID) if kaerr != nil { fmt.Println(err) } for { ka := &lt;-ch fmt.Println(&quot;ttl:&quot;, ka.TTL) }}","link":"/2022/09/18/20220918etcd%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85%E5%92%8Cgolang%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"title":"etcd集群的搭建","text":"etcd安装不说了详情请看上篇文章 启动服务节点112345678etcd --name etcd_t_0 --initial-advertise-peer-urls http://119.91.206.195:2380 \\ --listen-peer-urls http://0.0.0.0:2380 \\ --listen-client-urls http://0.0.0.0:2379 \\ --advertise-client-urls http://119.91.206.195:2379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster etcd_t_0=http://119.91.206.195:2380,etcd_t_1=http://1.117.72.9:2380,etcd_t_2=http://47.92.80.135:2380 \\ --initial-cluster-state new \\ --data-dir /var/lib/etcd5/ 节点212345678etcd --name etcd_t_1 --initial-advertise-peer-urls http://1.117.72.9:2380 \\ --listen-peer-urls http://0.0.0.0:2380 \\ --listen-client-urls http://0.0.0.0:2379 \\ --advertise-client-urls http://1.117.72.9:2379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster etcd_t_0=http://119.91.206.195:2380,etcd_t_1=http://1.117.72.9:2380,etcd_t_2=http://47.92.80.135:2380 \\ --initial-cluster-state new \\ --data-dir /var/lib/etcd5/ 节点312345678etcd --name etcd_t_2 --initial-advertise-peer-urls http://47.92.80.135:2380 \\ --listen-peer-urls http://0.0.0.0:2380 \\ --listen-client-urls http://0.0.0.0:2379 \\ --advertise-client-urls http://47.92.80.135:2379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster etcd_t_0=http://119.91.206.195:2380,etcd_t_1=http://1.117.72.9:2380,etcd_t_2=http://47.92.80.135:2380 \\ --initial-cluster-state new \\ --data-dir /var/lib/etcd5/ 常用操作 查看集群成员 12345678[root@VM-20-14-centos ~]# etcdctl member list --write-out=table+------------------+---------+----------+----------------------------+----------------------------+| ID | STATUS | NAME | PEER ADDRS | CLIENT ADDRS |+------------------+---------+----------+----------------------------+----------------------------+| 362499433afddc14 | started | etcd_t_1 | http://1.117.72.9:2380 | http://1.117.72.9:2379 || e4258ae59dee9dc3 | started | etcd_t_0 | http://119.91.206.195:2380 | http://119.91.206.195:2379 || feb1217e15f7013f | started | etcd_t_2 | http://47.92.80.135:2380 | http://47.92.80.135:2379 |+------------------+---------+----------+----------------------------+----------------------------+ 查看集群健康 1234[root@VM-20-14-centos ~]# etcdctl --endpoints=119.91.206.195:2380,1.117.72.9:2380,47.92.80.135:2380 endpoint health1.117.72.9:2380 is healthy: successfully committed proposal: took = 87.35868ms47.92.80.135:2380 is healthy: successfully committed proposal: took = 111.468497ms119.91.206.195:2380 is healthy: successfully committed proposal: took = 101.468497ms 查看集群状态 12345678[root@VM-20-14-centos ~]# etcdctl --endpoints=119.91.206.195:2380,1.117.72.9:2380,47.92.80.135:2380 endpoint status --write-out=table+---------------------+------------------+---------+---------+-----------+-----------+------------+| ENDPOINT | ID | VERSION | DB SIZE | IS LEADER | RAFT TERM | RAFT INDEX |+---------------------+------------------+---------+---------+-----------+-----------+------------+| 1.117.72.9:2380 | 362499433afddc14 | 3.3.11 | 20 kB | false | 15 | 9 || 47.92.80.135:2380 | feb1217e15f7013f | 3.3.11 | 16 kB | false | 15 | 9 || 119.91.206.195:2380 | e4258ae59dee9dc3 | 3.3.11 | 16 kB | true | 15 | 9 |+---------------------+------------------+---------+---------+-----------+-----------+------------+ 删除一个节点 12[root@VM-20-14-centos ~]# etcdctl member remove 362499433afddc14Member 362499433afddc14 removed from cluster 51573d7cfd299893 加入一个节点 123456[root@VM-20-14-centos ~]# etcdctl member add etcd_t_1 --peer-urls=http://1.117.72.9:2380Member c4356e396bf22311 added to cluster 51573d7cfd299893ETCD_NAME=&quot;etcd_t_1&quot;ETCD_INITIAL_CLUSTER=&quot;etcd_t_1=http://1.117.72.9:2380,etcd_t_0=http://119.91.206.195:2380,etcd_t_2=http://47.92.80.135:2380&quot;ETCD_INITIAL_CLUSTER_STATE=&quot;existing&quot; 新节点启动的时候使用以上输出的配置启动一定注意参数 故障主机加入节点 故障的etcd主机： 1systemctl stop etcd 移除故障节点 12[root@VM-20-14-centos ~]# etcdctl member remove 362499433afddc14Member 362499433afddc14 removed from cluster 51573d7cfd299893 查询集群成员 1234567+------------------+-----------+----------+----------------------------+----------------------------+| ID | STATUS | NAME | PEER ADDRS | CLIENT ADDRS |+------------------+-----------+----------+----------------------------+----------------------------+| 50466d8335f8506a | unstarted | | http://1.117.72.9:2380 | || e4258ae59dee9dc3 | started | etcd_t_0 | http://119.91.206.195:2380 | http://119.91.206.195:2379 || feb1217e15f7013f | started | etcd_t_2 | http://47.92.80.135:2380 | http://47.92.80.135:2379 |+------------------+-----------+----------+----------------------------+----------------------------+ 正常的etcd主机 123456[root@VM-20-14-centos ~]# etcdctl member add etcd_t_1 --peer-urls=http://1.117.72.9:2380Member c4356e396bf22311 added to cluster 51573d7cfd299893ETCD_NAME=&quot;etcd_t_1&quot;ETCD_INITIAL_CLUSTER=&quot;etcd_t_1=http://1.117.72.9:2380,etcd_t_0=http://119.91.206.195:2380,etcd_t_2=http://47.92.80.135:2380&quot;ETCD_INITIAL_CLUSTER_STATE=&quot;existing&quot; 故障的etcd主机，启动etcd后，再查看etcd状态： 一定要去修改故障主机的配置为：ETCD_INITIAL_CLUSTER_STATE=”existing” 123456# 先删除错误节点的数据rm -rf /var/lib/etcd/membersystemctl start etcd# 等待一会，这时候会同步数据，稍等再查看节点状态etcdctl endpoint health127.0.0.1:2379 is healthy: successfully committed proposal: took = 24.52485ms 到这里，etcd故障节点修复完毕 问题总结 这是集群中使用的etcd版本不一致的提示(这很有可能到导致集群不健康，至少我这个版本会，后来我全是yum install etcd)122022-09-25 21:59:44.187212 W | etcdserver: the local etcd version 3.1.5 is not up-to-date2022-09-25 21:59:44.187217 W | etcdserver: member feb1217e15f7013f has a higher version 3.3.11 如果在一个目录启动过etcd，要启动新的集群或者其他的新的实例，最好换个目录，他可能会导致无法启动。暴力点rm -rf ****** 故障的etcd主机，一定要去修改故障主机的配置为：ETCD_INITIAL_CLUSTER_STATE=existing 注意如果是前面修复过坏节点，下次启动集群的时候也不需要去修改坏节点的ETCD_INITIAL_CLUSTER_STATE=new 不同版本的etcd命令可能不一样，比如：添加节点 设置成existing，必须确保在启动时候其他member是存活的（peer端口），否则启动失败。用在扩容新实例的启动。设置成new，用在cluster已知member的启动。","link":"/2022/09/25/20220925etcd%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"title":"flutter极光推送集成华为(鸿蒙)厂商通道","text":"flutter插件jpush_flutter: 2.2.5,github 华为推送证书agconnect-services.json导出地址 极光开发者平台 客户端sdk集成官方文档 客户端华为厂商通道集成官方文档 极光推送排查工具 com.huawei.hms:push:X.X.X.XXX推送服务（Push Kit）是华为提供的消息推送平台，建立了从云端到终端的消息推送通道。您通过集成推送服务，可以向客户端应用实时推送消息，构筑良好的用户关系，提升用户的感知度和活跃度。 com.huawei.hms:push:X.X.X.XXX推送服务版本及其历史版本 com.huawei.agconnect:agcp:X.X.X.XXX华为分析服务（Analytics Kit）是针对移动应用、Web、快应用、快游戏、小程序等产品的一站式用户行为分析平台，贴合业务场景，提供数据采集、数据管理、数据分析、数据应用的一体化解决方案，驱动企业实现精准拉新、产品优化、精益运营、业务增长。 极光推送官方客户端集成，包括荣耀，OPPO，等等需要引入aar包，极光文档可能会更新，需要留意观看，看着他文档来就OK 极光推送基础集成1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class MyHomePage extends StatefulWidget { const MyHomePage({super.key, required this.title}); final String title; @override State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();}class _MyHomePageState extends State&lt;MyHomePage&gt; { JPush jpush = new JPush(); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ ElevatedButton(onPressed:(){ try { //Map&lt;String, dynamic&gt; message jpush.addEventHandler(onReceiveNotification: (message) async { print(&quot;jpush flutter onReceiveNotification: ${json.encode(message)}&quot;); }, onOpenNotification: (message) async { }, onReceiveMessage: (message) async { print(&quot;jpush flutter onReceiveMessage: ${json.encode(message)}&quot;); }, onReceiveNotificationAuthorization: (message) async { }); } on PlatformException { print(&quot;jpush Failed to get platform version.&quot;); } jpush.setup( appKey: &quot;bffe9289**********61869be9&quot;, channel: &quot;developer-default&quot;, production: false, debug: false, // 设置是否打印 debug 日志 ); jpush.applyPushAuthority(NotificationSettingsIOS( sound: true, alert: true, badge: true, )); jpush.getRegistrationID().then((rid) { print(&quot;jpush flutter get registration id : $rid&quot;); }); }, child: Text(&quot;setup&quot;)), ElevatedButton(onPressed:(){ jpush.applyPushAuthority(); }, child: Text(&quot;apply&quot;)), ElevatedButton(onPressed:(){ jpush.isNotificationEnabled().then((bool value) { print(&quot;jpush 通知授权是否打开: $value&quot;); }).catchError((onError) { print(&quot;jpush 通知授权是否打开: ${onError.toString()}&quot;); }); }, child: Text(&quot;通知&quot;)), ElevatedButton(onPressed:(){ jpush.setAlias(&quot;1000*****&quot;).then((map) { print(&quot;==setAlias==${map}==&quot;); }); }, child: Text(&quot;setAlias&quot;)) ], ), ), ); }} 厂商通道集成 gradle:6.7 distributionUrl=https://services.gradle.org/distributions/gradle-6.7-all.zip android/build.gradle———-classpath com.android.tools.build:gradle:4.1.3 jpush_flutter: 2.2.5 Jcore版本:3.2.2 Jpush版本: 4.6.4 (可以在flutter的插件地址Changelog中查看) android/build.gradle加上如下代码12345678910111213141516171819202122232425buildscript { ext.kotlin_version = '1.6.10' repositories { google() mavenCentral() // 加上如下代码 maven {url 'https://developer.huawei.com/repo/'} } dependencies { classpath 'com.android.tools.build:gradle:4.1.3' classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; // 加上如下代码 classpath 'com.huawei.agconnect:agcp:1.4.2.300' }}allprojects { repositories { google() mavenCentral() // 加上如下代码 maven { url 'https://developer.huawei.com/repo/' } }} agconnect-services.json放入到**android/app/**中进入到android/app/build.gradle12345apply plugin: 'com.android.application'apply plugin: 'kotlin-android'apply from: &quot;$flutterRoot/packages/flutter_tools/gradle/flutter.gradle&quot;// 加上如下代码（位置随意）apply plugin: 'com.huawei.agconnect' 引入厂商sdk极光厂商插件版本与接入 JPush 版本保持一致，下同，jpush版本可以在极光推送排查工具中查看 12345678910111213141516dependencies { // 接入华为厂商 implementation 'com.huawei.hms:push:5.3.0.301' implementation 'cn.jiguang.sdk.plugin:huawei:4.4.5'// 极光厂商插件版本与接入 JPush 版本保持一致，下同 // 接入小米厂商 implementation 'cn.jiguang.sdk.plugin:xiaomi:4.4.5' // 接入 FCM 厂商 // implementation 'com.google.firebase:firebase-messaging:21.0.1' // implementation 'cn.jiguang.sdk.plugin:fcm:4.0.0' // 接入魅族厂商 implementation 'cn.jiguang.sdk.plugin:meizu:4.4.5' // 接入 VIVO 厂商 implementation 'cn.jiguang.sdk.plugin:vivo:4.4.5' // 接入 OPPO 厂商 implementation 'cn.jiguang.sdk.plugin:oppo:4.4.5'} 修改AndroidManifest.xml12345678&lt;manifest ··· xmlns:tools=&quot;http://schemas.android.com/tools&quot; ···&gt; &lt;application ··· tools:replace=&quot;android:label&quot; 版本升级‘com.huawei.agconnect:agcp:1.5.2.300’ 这个版本是IDE自动提示我的如果版本不对他运行可能会报错!!!!,开头给力地址可以查找自己对应的版本 ‘com.huawei.hms:push:5.3.0.301’ 开头给力地址可以查找自己对应的版本 gradle:7.4 distributionUrl=https://services.gradle.org/distributions/gradle-7.4-all.zip android/build.gradle———-classpath ‘com.android.tools.build:gradle:7.1.2’ jpush_flutter: 2.4.0 Jpush版本: 4.8.4 (可以在flutter的插件地址Changelog中查看) aar的包位于android/app/libs/***.aar 12345678910111213141516171819202122232425262728293031323334buildscript { ... dependencies { classpath 'com.android.tools.build:gradle:7.1.2' classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; // 加上如下代码 classpath 'com.huawei.agconnect:agcp:1.5.2.300' } ....}dependencies { // 接入华为厂商 implementation 'com.huawei.hms:push:5.3.0.301' implementation 'cn.jiguang.sdk.plugin:huawei:4.8.4'// 极光厂商插件版本与接入 JPush 版本保持一致，下同 // 接入小米厂商 implementation 'cn.jiguang.sdk.plugin:xiaomi:4.8.4' // 接入魅族厂商 implementation 'cn.jiguang.sdk.plugin:meizu:4.8.4' // 接入 VIVO 厂商 implementation 'cn.jiguang.sdk.plugin:vivo:4.8.4' // 接入 OPPO 厂商 implementation 'cn.jiguang.sdk.plugin:oppo:4.8.4' implementation(name: 'com.heytap.msp-push-3.1.0', ext: 'aar') //以下为 OPPO 3.1.0 aar需要依赖 implementation 'com.google.code.gson:gson:2.6.2' implementation 'commons-codec:commons-codec:1.6' implementation 'androidx.annotation:annotation:1.1.0' //荣耀 implementation 'cn.jiguang.sdk.plugin:honor:4.8.4' implementation(name: 'HonorPushSDK-7.0.1.103', ext: 'aar')}","link":"/2022/10/05/20221005flutter%E9%9B%86%E6%88%90%E5%8D%8E%E4%B8%BA%E6%8E%A8%E9%80%81/"},{"title":"前端换肤解决方案及其思路","text":"CSS变量实现没什么好说的简单 使用stylus注意 –fill-1:#222;（正常） –fill-1: #222;（可能报错） 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script setup&gt; const change=(theme)=&gt;{ var html=document.querySelector(&quot;body&quot;) html.setAttribute(&quot;data-theme&quot;,theme) }&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;change('light')&quot;&gt;主题颜色亮色&lt;/button&gt; &lt;button @click=&quot;change('dark')&quot;&gt;主题颜色暗色&lt;/button&gt; &lt;div class=&quot;bg&quot;&gt;测试文字啊阿达瓦大大&lt;i&gt;家中的&lt;/i&gt;王阿达瓦&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;stylus&quot;&gt; //默认 :root { --fill-1:#ffffff; --text:#3c3c3c; --text-1:#757575; --text-2:#222; --font-size-large:18px; --font-size-large-x:22px; --font-size-medium:14px; --font-size-medium-x:16px; --font-size-small-s:10px; --font-size-small:12px; } [data-theme=&quot;dark&quot;] { --fill-1:#222; --text:#fff; --text-1:rgba(255, 255, 255, 0.3); --text-2:#ffcd32; } .bg transition-duration: 0.5s height: 100px background var(--fill-1); color: var(--text-2);&lt;/style&gt; js动态使用覆盖样式实现与scss变量实现会把多套皮肤的样式都编译到一个css文件里面，如果有多套皮肤样式，这个文件是会非常大的。 为了解决这样的问题，就自然的想出了拆分scss的实现，，通过编译工具与构建工具编译出多套皮肤css。或者使用网络地址。 通过js动态的link对应的皮肤样式 1234567891011121314var theme = /\\bt=(\\w+)/.exec(location.search);theme = theme ? theme[1] : &quot;light&quot;;changeTheme(theme);function changeTheme(theme) { var head = document.getElementsByTagName(&quot;head&quot;)[0]; var link = document.createElement(&quot;link&quot;); link.dataset.type = &quot;theme&quot;; link.href = &quot;assets/css/theme-&quot; + theme + &quot;/pages/home/home.css&quot;; link.rel = &quot;stylesheet&quot;; link.type = &quot;text/css&quot;; head.appendChild(link);} ElementUI换肤ElementUI的实现原理，通过预设的配置，颜色计算出颜色和生成正则，获取所有的style标签，拿到标签中的字符串，在去用正则替换字符串中的颜色，在设置回去。 为了考虑重复设置可以给style标签添加个标记 这个实现方式正如他官方所说相当暴力莫得感情！！！同时自己写的颜色也会被替换掉 颜色计算 前端正则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;script setup&gt;import Color from &quot;css-color-function&quot;;var current=&quot;default&quot;const formulaes = [ { name: &quot;0&quot;, exp: &quot;color(primary)&quot;, }, { name: &quot;aaa&quot;, exp: &quot;color(textColor)&quot;, }, { name: &quot;bbb&quot;, exp: &quot;color(btn)&quot;, },];///多个主题var themes={ default:{ &quot;primary&quot;:&quot;#DC143C&quot;, &quot;textColor&quot;:&quot;#BBFFAA&quot;, &quot;btn&quot;:&quot;#2F4F4F&quot; }, t1:{ &quot;primary&quot;:&quot;#FFD700&quot;, &quot;textColor&quot;:&quot;#000000&quot;, &quot;btn&quot;:&quot;#000080&quot; }, t2:{ &quot;primary&quot;:&quot;#2F4F4F&quot;, &quot;textColor&quot;:&quot;#FFFFFF&quot;, &quot;btn&quot;:&quot;#adff2f&quot; }}const computedColors = (colors) =&gt; { return formulaes.map((f) =&gt; { const value = f.exp .replace(/primary/g, colors.primary) .replace (/textColor/g,colors.textColor) .replace (/btn/g,colors.btn) return Color.convert(value); });};const PageInit=()=&gt;{ Object.keys(themes).forEach(k=&gt;{ var initColorCluster=[...Object.values(themes[k]),...computedColors(themes[k])] var initStyleReg=initColorCluster.join(&quot;|&quot;) .replace(/\\(/g, &quot;\\\\(&quot;) // 括号的转义 .replace(/\\)/g, &quot;\\\\)&quot;) .replace(/0\\./g, &quot;.&quot;); // 这里替换是因为默认的css中计算出来的值透明度会缺省0， themes[k]._initColorCluster=initColorCluster themes[k]._initStyleReg=initStyleReg })}PageInit()const changeTheme = (t) =&gt; { var cT=themes[current], tT=themes[t]; const styles = Array.from(document.querySelectorAll(&quot;style&quot;)).filter((style) =&gt; { // 找到需要进行替换的style标签 const text = style.innerText; const re = new RegExp(`${cT._initStyleReg}`, &quot;i&quot;); return re.test(text); }); ///生成正则 const re = new RegExp(`${cT._initStyleReg}`, &quot;ig&quot;); // 老的颜色簇正则，全局替换，且不区分大小写 styles.forEach((style) =&gt; { const { innerText } = style; style.innerHTML = innerText.replace(re, (match) =&gt; { ///通过小写检查 rgba(0,0,0,.5) 替换成0.5 兼容好 let index = cT._initColorCluster.indexOf(match.toLowerCase().replace(&quot;.&quot;, &quot;0.&quot;)); ///通过大写写检查 if (index === -1)index = cT._initColorCluster.indexOf(match.toUpperCase().replace(&quot;.&quot;, &quot;0.&quot;)); // 进行替换 return tT._initColorCluster[index].toLowerCase().replace(/0\\./g, &quot;.&quot;); }); // console.log(style.innerHTML) // style.setAttribute(&quot;class&quot;, &quot;so-ui-react-theme&quot;); }); current=t; console.log(&quot;当前主题：%s&quot;,current)};const change=()=&gt;{ if(current===&quot;default&quot;){ changeTheme(&quot;t1&quot;) }else if(current===&quot;t1&quot;){ changeTheme(&quot;t2&quot;) }else{ changeTheme(&quot;default&quot;) }}// componentDidMount();&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;a b&quot;&gt;testaaaaaai&lt;/div&gt; &lt;button class=&quot;b c&quot; @click=&quot;change&quot;&gt;更换颜色&lt;/button&gt;&lt;/template&gt;&lt;style scoped&gt;.a{ background: #DC143C;}.b{ color: #BBFFAA;}.c{ background:#2F4F4F;}&lt;/style&gt; less实现换肤感觉less实现的很优雅 设置默认样式，原来它会找到所有如下的less样式标签，并且使用已编译的css同步创建 style 标签。 相当于在原来的基础上生成一个一模一样的style样式表添加到页面中。也就是说他需要一个模板。如果放在src里面他会被编译成css，无法成为模板。 我们这里把这个模板放到项目主目录的public中去。。 1234567891011121314151617/public/test.less@primary-color: red;@bg-color: blue;.test-block { width: 300px; height: 300px; text-align: center; line-height: 300px; margin: 20px auto; color: @primary-color; background: @bg-color; .block2 { color: aquamarine; }} 修改项目模板文件index.html，添加lessjs，也可以搞成本地的的，我这里为了方便直接添加cdn的 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Vite + Vue&lt;/title&gt; &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;/test.less&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt;window.less = {async:true,}&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/less.js/2.7.3/less.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 页面简单使用 12345678910111213141516171819202122232425262728&lt;script setup&gt;var themes={ t1:{ &quot;@primary-color&quot;: &quot;#8b0000&quot;, &quot;@bg-color&quot;: &quot;#2f4f4f&quot;, }, t2:{ &quot;@primary-color&quot;: &quot;#ffa500&quot;, &quot;@bg-color&quot;: &quot;#c0c0c0&quot;, }, t3:{ &quot;@primary-color&quot;:&quot;#000080&quot;, &quot;@bg-color&quot;: &quot;#000000&quot;, }}const onchange=(t)=&gt;{ console.log(themes[t]) window.less.modifyVars(themes[t]).then(() =&gt; { console.log(&quot;修改成功&quot;); });}&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;onchange('t1')&quot;&gt;改变哦&lt;/button&gt; &lt;button @click=&quot;onchange('t2')&quot;&gt;改变哦&lt;/button&gt; &lt;button @click=&quot;onchange('t3')&quot;&gt;改变哦&lt;/button&gt; &lt;div class=&quot;test-block&quot;&gt;testaaaaaai&lt;/div&gt;&lt;/template&gt; 其他思路vuex，自定义指令等等实现起来应该也很不错。理论上他们也能获得较高的自定义程度，颜色，背景图等等等。","link":"/2022/10/25/20221025%E5%89%8D%E7%AB%AF%E6%8D%A2%E8%82%A4%E6%80%9D%E8%B7%AF/"},{"title":"flutter类中的构造函数","text":"传统的构造函数12345678910class Student { int age = 0; int id = 0; String? name=&quot;&quot;; Student(int age, int id) { this.age = age; this.id = id; }} 命名构造函数12345678910111213141516class Student { int? age = 0; int? id = 0; String? name=&quot;&quot;; Student(this.age, this.id,); Student.fromJson(Map data) { print('命名构造函数'); this.name=data[&quot;name&quot;]; }}var b=Student.fromJson({&quot;firstName&quot;:&quot;AAAAA&quot;});print(b.firstName);///AAAAA Student.fromJson 不固定也可以叫Student.fromJson1，Student.fromJson2 继承构造函数的执行顺序1234567891011121314151617181920212223242526class Student { String? firstName; Student(){ print('in Student con'); } Student.fromJson(Map data) { print('in Student'); this.firstName=data[&quot;firstName&quot;]; }}class Jone extends Student { Jone(){ print('in Jone con'); } Jone.fromJson(Map data) : super.fromJson(data) { print('in Jone'); }}var b=Student.fromJson({&quot;firstName&quot;:&quot;AAAAA&quot;});print(b.firstName);///in Student///AAAAA 调用初始化列表（初始化列表就是在构造函数执行之前执行的代码，和调用父类的构造函数一样，也使用：操作符，如下所示：） 下面：后面的赋值就是出初始化列表 12345Point.fromJson(Map&lt;String, double&gt; json) : x = json['x']!, y = json['y']! { print('In Point.fromJson(): ($x, $y)');} 调用父类的构造函数 调用自己的构造函数 重定向构造函数12345678910111213141516class Point { double x, y; // 主构造函数 Point(this.x, this.y); // 构造函数 Point.formJson(double x){} // 重定向到主构造函数 Point.alongXAxis(double x) : this(x, 0); // 重定向到formJson构造函数 Point.alongXAxis2(double x) : this.formJson(x);} 工厂构造函数默认情况下，dart类中的构造函数返回的是该类的新实例，但是我们在实际的应用中可能会对返回的对象做些选择，比如从缓存中返回已经存在的对象，或者返回该类具体的实现子类。为了实现这样的功能，dart中专门有一个Factory关键字，使用Factory的构造函数叫做工厂构造函数。 那么问题来了，factory构造函数和普通构造函数到底有什么区别呢?最大的区别就是普通构造函数是没有返回值的，而factory构造函数需要一个返回值。 Map.putIfAbsent方法回顾，下面备用 123456789101112131415Map user = { 'name': 'Tom', 'age': 20 };var b=user.putIfAbsent('job', () =&gt; 'engineer');print(user);print(b);b=user.putIfAbsent('job', () =&gt; 'engineer22222222222');print(user);print(b); // {name: Tom, age: 20, job: engineer}// engineer// {name: Tom, age: 20, job: engineer}// engineer 例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void main(List&lt;String&gt; args) { Student stu0 = Student(&quot;dart0&quot;,99); Student stu1 = Student(&quot;dart&quot;,1); Student stu2 = Student(&quot;dart&quot;,2); Student stu3 = Student.fromJson({&quot;name&quot;: &quot;dart&quot;,&quot;age&quot;:3}); Student stu4 = Student.fromJson2({&quot;name&quot;: &quot;dart&quot;,&quot;age&quot;:4}); print(&quot;============================&quot;); // 使用 Student() 工厂构造函数 和 Student.fromJson({}) 工厂构造函数创建出来的对象是同一个对象 print(identical(stu0, stu1)); // false print(identical(stu1, stu2)); // true print(identical(stu2, stu3)); // true print(identical(stu3, stu4)); // false print(&quot;============================&quot;); print(stu1.age); // 1 print(stu2.age); // 1 print(stu3.age); // 1 print(stu4.age); // 10 print(&quot;============================&quot;); print(stu0.hashCode);///595483760 print(stu1.hashCode); ///959865253 print(stu2.hashCode); ///959865253 print(stu3.hashCode); ///959865253 print(stu4.hashCode);///730863203}class Student { String? name; int age=0; static final _cache = &lt;String, Student&gt;{}; static final test = &lt;int&gt;[]; // 工厂构造函数 factory Student(String name,int age) { test.add(age); print(test); Student s =_cache.putIfAbsent(name, () =&gt; Student.useForFactory(name,age)); return s; } // 工厂构造函数 factory Student.fromJson(Map json) { return Student(json['name'],json['age']); } // 命名构造函数 Student.fromJson2(Map json):name=json[&quot;json&quot;],age=10; Student.useForFactory(this.name,this.age);} 如上的例子伪解释一下 1234567先声明一下，比如我们声明了一个Student类，static final _cache 我们需要把他解读成一个全局单独的变量(或者说应用的一块单独内存)，上面特地加了static final test = &lt;int&gt;[] 更加清晰明了。Student(&quot;dart&quot;,1) 向全局单独的变量_cache存入了一个键值对 { &quot;dart&quot; ：Student.useForFactory(&quot;dart&quot;,1)}Student(&quot;dart&quot;,2) 则 不会！！！继续向全局单独的变量_cache存入了一个键值对，因为_cache中的键 &quot;dart&quot; 已经存在了，所以他会直接返回Student.useForFactory(&quot;dart&quot;,1)，这里使用的是Map.putIfAbsent实现。 反例 123456789101112131415161718192021222324252627282930313233343536373839void main(List&lt;String&gt; args) { Student stu1 = Student(&quot;dart&quot;,1); Student stu2 = Student(&quot;dart&quot;,2); Student stu3 = Student.fromJson({&quot;name&quot;: &quot;dart&quot;,&quot;age&quot;:3}); Student stu4 = Student.fromJson2({&quot;name&quot;: &quot;dart&quot;,&quot;age&quot;:4}); print(&quot;============================&quot;); // 使用 Student() 工厂构造函数 和 Student.fromJson({}) 工厂构造函数创建出来的对象是同一个对象 print(identical(stu1, stu2)); // false print(identical(stu2, stu3)); // false print(identical(stu3, stu4)); // false print(&quot;============================&quot;); print(stu1.age); // 1 print(stu2.age); // 2 print(stu3.age); // 3 print(stu4.age); // 10}class Student { String? name; int age=0; static final _cache = &lt;String, Student&gt;{}; // 工厂构造函数 factory Student(String name,int age) { return Student.useForFactory(name,age); } // 工厂构造函数 factory Student.fromJson(Map json) { return Student(json['name'],json['age']); } // 命名构造函数 Student.fromJson2(Map json):name=json[&quot;json&quot;],age=10; Student.useForFactory(this.name,this.age);} 当然工厂构造函数也能实现单例 123456789101112class Singleton { static final Singleton _singleton = Singleton.internal(); factory Singleton() =&gt; _singleton; Singleton.internal();}Singleton s1=Singleton();Singleton s2=Singleton();print(identical(s1, s2));///true 注意，dart中只能有一个未命名的构造函数，对应命名函数来说，名字不能够重复，否则会报The default constructor is already defined异常。所以如果你再给Student加一个未命名构造函数：Student(this.name)因为已经有了 factory Student(String name)","link":"/2021/12/09/20211219flutter%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"web前端","slug":"web前端","link":"/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"uniapp","slug":"uniapp","link":"/tags/uniapp/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"exceljs","slug":"exceljs","link":"/tags/exceljs/"},{"name":"sheetjs","slug":"sheetjs","link":"/tags/sheetjs/"},{"name":"nuxtjs","slug":"nuxtjs","link":"/tags/nuxtjs/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"gulp","slug":"gulp","link":"/tags/gulp/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"pinia","slug":"pinia","link":"/tags/pinia/"},{"name":"cryptojs","slug":"cryptojs","link":"/tags/cryptojs/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"webAssembly","slug":"webAssembly","link":"/tags/webAssembly/"},{"name":"Google Sign","slug":"Google-Sign","link":"/tags/Google-Sign/"},{"name":"Face Sign","slug":"Face-Sign","link":"/tags/Face-Sign/"},{"name":"im","slug":"im","link":"/tags/im/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"etcd","slug":"etcd","link":"/tags/etcd/"},{"name":"极光推送","slug":"极光推送","link":"/tags/%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81/"}],"categories":[{"name":"web前端","slug":"web前端","link":"/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"flutter","slug":"flutter","link":"/categories/flutter/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"docker","slug":"docker","link":"/categories/docker/"}]}